<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Etizolam]]></title>
  <link href="http://jhotta.github.io/atom.xml" rel="self"/>
  <link href="http://jhotta.github.io/"/>
  <updated>2014-06-14T17:27:26+09:00</updated>
  <id>http://jhotta.github.io/</id>
  <author>
    <name><![CDATA[@jhotta]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DockerHubとlibswarmの提供で、エコシステム基盤の定義?]]></title>
    <link href="http://jhotta.github.io/blog/2014/06/13/what-i-think-about-libswarm-1/"/>
    <updated>2014-06-13T13:29:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/06/13/what-i-think-about-libswarm-1</id>
    <content type="html"><![CDATA[<p><a href="http://www.dockercon.com/">dockercon14</a>が終わって、僕が注目したいのは、<a href="https://hub.docker.com/">DockerHub</a>と<a href="https://github.com/docker/libswarm">Libswarm</a>です。</p>

<p>僕は、LibswarmとDockerHubの関係に関してgitとgithubの関係に似ているような気がしてます。<a href="http://www.publickey1.jp/blog/14/docker_hubdockerdocker.html">[速報]Docker Hub発表。ビルド、テスト、デプロイの自動化、Dockerイメージの管理など。Dockerのプラットフォーム化を推進(Publickey)</a>にも書かれているように、<strong>&ldquo;実行可能なアプリケーションのDockerイメージを管理する機能などを備えたサービス&rdquo;</strong>なんだとすると、そのDockerイメージをCLIやプログラム内から使い倒すの必要なのがlibswarmではないかと思います。</p>

<p><img class="right" src="http://jhotta.github.io/images/blog-images/Docker_the_road_ahead.png" width="300" height="300" title="Docker the road ahead" alt="Docker the road ahead"></p>

<p>DockerHub&amp;libswarm共に未だ発表されて間もないしので検索してもあまり情報が見つからないのですが、次の幾つかのサイトを見ていると、新しい時代の幕開けが目の前で始まっている感じがし、ワクワクしてしかたがない。</p>

<ul>
<li><a href="http://www.slideshare.net/shykes/docker-the-road-ahead">Docker: the road ahead</a></li>
<li><a href="https://www.youtube.com/watch?v=a_YbxWbHgQA">Orchard + libswarm demo from DockerCon</a></li>
<li><a href="http://www.activestate.com/blog/2014/06/libswarm-docker-orchestration-announced">libswarm &ndash; Docker Orchestration Announced</a></li>
<li><a href="http://java.dzone.com/articles/libswarm-docker-orchestration?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+javalobby%2Ffrontpage+%28Javalobby+%2F+Java+Zone%29">libswarm &ndash; Docker Orchestration Announced</a></li>
</ul>


<p>そして<a href="http://www.publickey1.jp/blog/14/docker_hubdockerdocker.html">Publickeyの記事</a>のまとめで、<strong>&ldquo;ここから見えてくるのは、Docker社のチャレンジは単にLinuxのコンテナ技術を製品化するだけでなく、これまで主にOSベンダーが築いてきたOSを中心とした開発ツールやアプリケーションベンダーとのエコシステムを、コンテナ型仮想化技術を核に再構築しようとしているところです。いまのDockerの勢いを見ていると、このエコシステムの構築とDockerのプラットフォーム化の実現は一定のに説得力があるように思います。&rdquo;</strong>って、非常に意味のある言葉のような気がしています。(僕は、&#8221;OSベンダー&#8221;を、&#8221;インフラ提供者&#8221;と理解してまとめに共感しています。)</p>

<p>githubエコシステムができたことで”コードに対する価値感”や”開発の進め方”が大きく変わったように、<strong>Dockerエコシステム</strong>が形成されていくことで、開発運用の方法が根底から変わっていくのではないかと思います。</p>

<p>そしてクラウドインフラの利用者側として、僕が今感じているのは、「今までのやり方は時代遅れになる、できるところから地道に次の準備を始めるしかない!」ってことかなぁと思う。</p>

<pre><code>- 「時代遅れが、通用しない」とは言っておりません。
- インフラ供給者側の視点は、怖くて書けません…。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[コンテナ化したDatadog agentを使ってDockerのモニターリング&管理]]></title>
    <link href="http://jhotta.github.io/blog/2014/06/11/docker-ize-datadog-with-agent-containers/"/>
    <updated>2014-06-11T11:31:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/06/11/docker-ize-datadog-with-agent-containers</id>
    <content type="html"><![CDATA[<p>さすがに<a href="http://www.dockercon.com/">dcokercon14</a>が開催されているということもあって、Dockerネタで2日連続で記事を掲載してきたか…。
ということで、この記事も日本語訳してみることにする。(超訳っぽいところは、寛大な心をもって読んでください。)</p>

<p>尚この記事を読む前にDcokerのドキュメントの<a href="http://docs.docker.com/reference/run/#runtime-privilege-and-lxc-configuration">Runtime Privilege and LXC Configuration</a>の部分に目を通しておくと良いかもしれない。Datadog agentをインストールするコンテナは、このPrivilege機能を使って他のコンテナの情報にアクセスしていると思う。</p>

<h2>Docker-ize Datadog with agent containers</h2>

<p><a href="https://www.datadoghq.com/2014/06/docker-ize-datadog/">Docker-ize Datadog with agent containers (原文)</a></p>

<p><a href="http://www.docker.com/">Docker</a> is an exciting technology that offers a different approach to building and running applications thanks to a clever combination of linux containers (good for ops) and a git-like approach to packaging software (good for dev) so that your containers have everything they need to run without dependencies.</p>

<p><a href="http://www.docker.com/">Docker</a>は、アプリケーションシステムを構築し運用するための刺激的なテクノロジーです。
このテクノロジーは、Linuxコンテナとgitのようなソフトウェアパッケージングの巧みな組み合わせのおかげで、他に依存することなくそれ自身で完全に動作することができます。</p>

<p>Many of you who are using Docker are embracing the Docker way and taking a container-only approach. As we release our <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">new Docker integration</a>, we don’t want to force you to break from a container-only strategy because of the traditional Datadog agent architecture. Instead, we’ve also embraced the Docker way and we’re pleased to announce a Docker-ized Datadog agent deployed in a container.</p>

<p>Dockerを採用しているユーザーは、Dockerの一般的な用法(the Docker way)に従い自分たちのアプリケーション用コンテナのみを起動するアプローチ(container-only approach)を採用しているでしょう。
Datadogが<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Docker用の新しいIntegration</a>をリリースしたのは、旧バージョンのDatadog agentのアーキテクチャの問題で、Datadogユーザーが、<strong>container-only</strong>アプローチを断念してほしくなかったからです。Datadogでは<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Docker用の新しいIntegration</a>にとどまらず、Dockerの一般的な用法(the Docker way)に従い、Datadog agentをインストールしたコンテナも準備しました。</p>

<h3>The Docker philosophy</h3>

<p>First, a brief introduction on how infrastructure is set up with Docker. In Docker, each of your applications is isolated in its own container. The blueprint for a container is its DockerFile which is a set of steps to create the container. These steps build the standard binaries and libraries and install your application’s code and its dependencies such as Python, <a href="http://www.johnmcostaiii.net/2013/installing-redis-on-docker/">Redis</a>, Postgres, etc.</p>

<p>まず、Dockerでどのようにシステムインフラがセットアップされるか簡単に紹介します。
Dockerでは、各アプリケーションはコンテナごとに隔離されています。
各コンテナの設計図である<strong>DockerFile</strong>には、コンテナの中身を設定していく手順が記述されています。
この設定手順には、標準的なバイナリやライブラリをビルドしたり、アプリケーションのコードとそのアプリケーションが依存するPython、<a href="http://www.johnmcostaiii.net/2013/installing-redis-on-docker/">Redis</a>、Postgresなどの依存ファイルをインストールする手順が記述されています。</p>

<p>The Docker engine then creates the actual container to run using namespaces and cgroups. These are two features found in recent versions of the Linux kernel used to isolate system calls and resource usage (CPU, memory, disk I/O, etc.) directly on your server. The end result is multiple containers on the server with each application thinking it is in its own machine by itself, without the overhead associated with fully-virtualized machines.</p>

<p>Dockerエンジンは、名前空間とcgroupsを使用し実行用の実コンテナを準備します。
最近のLinuxカーネルは、これらの名前空間とcgroupsの機能を使い、システムコールの隔離とホストサーバ上のリソース(CPU, memory, disk I/O, etc.) に対する利用制限を実現しています。結果従来型の仮想化技術のようなパフォーマンス低下の影響をうけることなく、ホストサーバ上の個々コンテナ内のアプリケーションは、個別のマシンを占有し動作しているのと同じ状態になります。</p>

<h3>The traditional Datadog set-up</h3>

<p>Until Docker arrived, applications were built in virtual servers or directly on raw servers. In this case, you <a href="http://docs.datadoghq.com/">install the agent</a> on your server and decide what applications and services you want to monitor in Datadog. If you want to send custom metrics to Datadog, you instrument your application with our Datadog version of StatsD, called <a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>. This set-up is illustrated below.</p>

<p>Dockerが一般化する以前は、アプリケーションは物理サーバか従来型仮想サーバ上に構築されていました。このような場合では、各サーバに<a href="http://docs.datadoghq.com/">Datadog agentをインストールし</a>、監視対象のアプリケーションやサービスを決めていきます。任意のメトリックス(指標)をDatadogに転送したないなら、<a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>(DatadogバージョンのStatsD)を使って、アプリケーションにメトリック(指標)採取用のコードを追記することになります。</p>

<p>Datadog agentの配置は、次のような配置になります。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/Traditional-2.png" width="800" height="800" title="Traditional way" alt="Traditional way"></p>

<p>The traditional Datadog set-up in the Docker environment means the Datadog agent runs next to the Docker engine.</p>

<p>Docker環境での伝統的なDatadogのセットアップでは、Datadog agentをDokcerエンジンのとなりで起動していました。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage1.png" width="400" height="400" title="Where the agent fits in a Docker environment" alt="Where the agent fits in a Docker environment"></p>

<h3>Datadog the Docker Way</h3>

<p>Because the Docker philosophy is to isolate applications to a container, we have built a “Docker-ized” installation of the Datadog agent. We have isolated the agent into two kinds of Docker containers. Both of the container installations can be illustrated by the diagram below.</p>

<p>Dockerの哲学がアプリケーションをコンテナに収納しそれぞれを隔離することなので、Datadogでも<strong>“Docker-ized”</strong>(コンテナに収納)したDatadog agentを作ってみました。</p>

<p>下記に示すdd-agent&amp;dogstatsdコンテナ又はdogstatsdコンテナは、次の図のような配置になります。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerizeImage2.png" width="600" height="600" title="Docker-ized Datadog" alt="Docker-ized Datadog"></p>

<p>The first container includes the Datadog agent plus DogStatsD. The Datadog agent is responsible for sending us both native host and container-specific metrics, like number of containers, load, memory, disk usage, and latency. DogStatsD will send us custom metrics you have instrumented in containerized applications. Again, you can read more about what exactly Datadog monitors in Docker in our <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog</a> post.</p>

<p>最初に紹介するコンテナには、Datadog agentとDogStatsDがインストールされています。
このコンテナのDatadog agentは、Dokcerをホストしているサーバとコンテナ固有のメトリック(指標)の両方を送信します。例えば、コンテナ数、負荷、メモリ、ディスク使用量、レーテンシー時間等が含まれます。DogStatsDは、コンテナ内に収めたアプリケーションに設定した任意のメトリックス(指標)を転送します。Datadogが、Dockerに関し収集しているメトリックスの詳細を調べる方法を知りたい場合は、<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Monitor Docker with Datadog</a>の記事を参照してください。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM datadog/docker-dd-agent
</span><span class='line'>
</span><span class='line'># Set your API key
</span><span class='line'>RUN sed -i -e"s/^.*api_key:.*$/api_key: EXAMPLE_API_KEY/" /etc/dd-agent/datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>If you only want to monitor custom metrics in containerized applications, the other Datadog container isolates DogstatsD so that you can send us custom metrics to monitor.</p>

<p>コンテナ内のアプリケーションの任意のメトリックス(指標)のみを監視したい場合は、DogstatsDを収納した別のDatadogコンテナ(dogstatsdコンテナ)を利用します。
このコンテナを利用することで、任意のメトリックス(指標)をDatadogに送信することができるようになります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM datadog/docker-dogstatsd
</span><span class='line'>
</span><span class='line'># Set your API key
</span><span class='line'>RUN sed -i -e"s/^.*api_key:.*$/api_key: EXAMPLE_API_KEY/" /etc/dd-agent/datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>For detailed documentation on how to install the Docker-ized Datadog containers, please visit our <a href="https://github.com/DataDog/dd-agent/wiki/Docker-Containers">Docker installation guide</a>.</p>

<p><strong>Docker-ized Datadog</strong>コンテナのインストール方法に関する詳細は、<a href="https://github.com/DataDog/dd-agent/wiki/Docker-Containers">Docker installation guide</a>を参照してください。</p>

<p>As mentioned in the <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog</a> post, if you would like to alert on and visualize Docker metrics, you can sign-up for a <a href="https://app.datadoghq.com/signup">14-day free trial of Datadog</a>. Docker metrics will be available immediately after installing the Datadog agent in its traditional format or as a container.</p>

<p>先の<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Monitor Docker with Datadog</a>の記事でも書いたように、Dockerのメトリックス(指標)を使って状況の可視化や通知をしたい場合は、<a href="https://app.datadoghq.com/signup">14日間のフリートライアル</a>を試してみてください。
Datadog agentをインストールした後、直ちにDockerエンジン、コンテナ、ホストマシンのメトリックス(指標)を監視できるようになります。</p>

<p>by <a href="https://www.linkedin.com/in/zahedahaidri">ZAHEDA HAIDRI</a> (Datadog, Inc)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[モニターリングサービスのDatadogを使ってDockerをモニターリング&管理]]></title>
    <link href="http://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/"/>
    <updated>2014-06-10T10:50:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog</id>
    <content type="html"><![CDATA[<p>「今日は、<a href="http://www.dockercon.com/">dockercon14</a>がサンフランシスコで開催されているな〜」と思っていたら、Datadog blogからもDocker関連の面白い記事が掲載されました。</p>

<p>Datadog agent 4.3.1をDockerホストOS上で起動し、他のアプリと同じようにIntegration用のYAMLファイルを設定することでDcoker内の各コンテナの状態をモニターリングできるということです。</p>

<p><a href="https://www.datadoghq.com">Datadog</a>の<a href="https://twitter.com/alq">@alq</a>が「もちろん翻訳してもいいよ〜! (Yes! Of course.)」言ってくれているので、次に日本語で同記事を転載します。</p>

<p>その前に次のシリーズを読んでおくと、Datadogはどうやってメトリックスを集めようしているのかが理解できると思います。</p>

<ul>
<li><a href="http://gihyo.jp/admin/serial/01/linux_containers/0003">第3回　Linuxカーネルのコンテナ機能［2］ ─cgroupとは？（その1）</a></li>
<li><a href="http://gihyo.jp/admin/serial/01/linux_containers/0002">第2回　コンテナの仕組みとLinuxカーネルのコンテナ機能［1］名前空間とは？</a></li>
<li><a href="http://gihyo.jp/admin/serial/01/linux_containers/0001">第1回　LXCとコンテナの基本</a></li>
</ul>


<h2>Monitor Docker with Datadog</h2>

<p><a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog(原文)</a></p>

<p>Docker is an emerging platform to build and deploy software using lightweight, pared-down virtual machines known as containers. By delivering easy-to-provision recipes for developers and bit-for-bit compatibility between environments, Docker is a popular solution to solve continuous delivery in modern infrastructure.</p>

<p><a href="http://www.docker.com/">Docker</a>は、既存の仮想環境から贅肉を削ぎ落とし軽量化したLinuxコンテナという仕組みを使用し、ソフトウェアシステムを構築&amp;展開するための新たなプラットフォームです。Dockerは、アプリ開発者に簡単にプロビジョニングできるレシピを提供することと環境間の再現性を上げることで、現代インフラでの継続的デリバリーを実現する最も人気のある方法になりました。</p>

<p>Like virtual machines before them, containers require a new monitoring approach. Luckily, if you are a Datadog user, you can now take advantage of our newest integration: Docker.</p>

<p>従前の仮想マシンと同様に、Linuxコンテナでも新しい監視アプローチが必要にまります。Datadogユーザーであれば幸いなことに、最新のDocker Integrationの恩恵を受けることができます。</p>

<p>With our Docker integration you can monitor containers by running version 4.3.1 of the Datadog agent. The integration configuration is, like all other agent-based integrations, a simple YAML file.</p>

<p>バージョン4.3.1の<a href="http://docs.datadoghq.com/guides/basic_agent_usage/">Datadog agent</a>を導入することで、Docker Integrationを使ってコンテナを監視することができるようになります。
Docker Integrationの設定方法は、今まであった他のアプリケーションのIntegrationと同じように簡単な<a href="https://github.com/DataDog/dd-agent/blob/master/conf.d/docker.yaml.example">YAMLファイル形式</a>になっています。</p>

<h3>How Docker monitoring works</h3>

<p>The simplest way to monitor Docker containers is to run the Datadog Agent on the host, where it can access container statistics. This is especially true if you are deploying Docker on existing, full-fledged Host OSes, along existing applications such as databases.</p>

<p>Dcokerコンテナを監視するための最も簡単な方法は、コンテナのスタティック情報にアクセスできるホスト上でDatadog Agentを実行することです。本格的なホストOSにデータベースなどの既存のアプリケーションと共にDockerを展開するなら、尚更この方法は有効です。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage1.png" width="400" height="400" title="Where the agent fits in a Docker environment" alt="Where the agent fits in a Docker environment"></p>

<p>Since Docker uses existing kernel constructs (namespaces and cgroups) in order to run containers, the Datadog Agent uses the native cgroup accounting metrics to gather CPU, memory, network and I/O metrics of the containers every 15 seconds before they are forwarded to Datadog.</p>

<p>Dockerは、コンテナを実行するために既存のカーネル構成体（名前空間とcgroup）を使用しています。
Datadog agentは、このカーネル構造体のcgroupか提供するトリックス(指標)を使ってCPU、メモリ、ネットワーク、15秒ごとのコンテナI/Oの情報を収集し、Datadogに転送しています。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage2_Screenboard.png" width="800" height="800" title="A Docker ScreenBoard" alt="A Docker ScreenBoard"></p>

<h3>Monitor many containers efficiently with tags</h3>

<p>With easy-to-use, lightweight containers, you will likely dial up several times more running containers than the number of underlying physical or virtual hosts in your infrastructure. How do you then keep track and monitor them without spending time chasing after every single one of them? With tags.</p>

<p>簡単に使用でき軽量なコンテナを使うと、インフラストラクチャ内にある物理マシンまたは仮想ホストの数の数倍のコンテナを起動することになるでしょう。あなたらな、どのように時間をかけずに追跡し又監視しますか?　タグを使っては、どうでしょう!</p>

<p>Tags are the key to monitoring a lot of containers without additional effort. By default, the agent will monitor your containers and turn the Docker “name”, “image” and “command” attributes into a “tag”.</p>

<p>追加の努力をせずに大量のコンテナを監視するためには、<a href="http://docs.datadoghq.com/guides/metrics/#tags">タグ付け</a>が有効な解決策です。何もしなくてもDatadog agentは、Dockerの「名前」,「イメージ名」,「コマンド」の属性をタグに追加します。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage3_tags.png" width="800" height="800" title="Tags" alt="Tags"></p>

<h3>Graph specific metrics with tags</h3>

<p>In Datadog, you define the metrics shown in dashboards and graphs based on one or many tags. This allows you to track specific metrics for many containers in aggregate. Using tags, you can easily create a graph for a metric drawn from all containers running a given image.</p>

<p>Datadogでは、タグの組み合わせに基づいてダッシュボードやグラフに表示するメトリック(指標)を定義することができます。この複数のタグの組み合わせによって統計的に複数のコンテナの特定のメトリックス(指標)を追跡することができるようになります。又タグを使用すると、同じDockerイメージから起動しているコンテナのメトリックス(指標)を手軽にグラフを描くこともできます。</p>

<p>In the example below, we are showing the amount of CPU consumed, broken down by image.</p>

<p>以下の例では、CPUの消費量をDockerイメージの分類で表示しています。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage4_graph_by_image.png" width="800" height="800" title="Using tags to visualize Docker performance" alt="Using tags to visualize Docker performance"></p>

<h3>Alerts</h3>

<p>Tags are also very useful to define alerts that span clusters of containers. For instance, let us say that you are running a cluster of Redis containers and you want to be alerted when one of the containers is running out of memory.</p>

<p>タグの使用は、コンテナをクラスター化し、そのクラスターにアラートを定義するのに非常に便利です。たとえば、Redisが起動しているコンテナのクラスターを運用中、クラスタ内のどれかのコンテナにメモリの不足が発生した場合に、アラートを受け取るようにしたいとしましょう​​。</p>

<p>Instead of defining one alert per container, you only have to create a multi-alert on the docker.mem.rss metric and Datadog will trigger an alert if any container misbehaves.</p>

<p>各コンテナごとにアラートの定義する代わりに、<code>docker.mem.rss</code>のメトリックス(指標)を基に、<strong>multi-alert</strong>を設定します。Datadogでは、この設定によって任意のコンテナでの誤作動によりアラートを送信することができます。</p>

<p>You can also mix and match tags to express more complex conditions. For instance, you can monitor all Redis containers running the redis2.8 image that run on host alq-docker with a simple tag selection:</p>

<p>又タグは、より複雑な条件を設定するためにタグを組み合わせてマッチングさせることができます。たとえば、簡単なタグ選択により、ホスト名<code>alq-docker</code>上で実行されているDockerイメージ<code>redis2.8</code>のすべてのRedisのコンテナを監視することができます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage5-multi-alert.png" width="800" height="800" title="Monitoring all containers" alt="Monitoring all containers"></p>

<h3>Monitor your containers’ lifecycles</h3>

<p>Since containers are designed to be as short-lived (or long-lived) as traditional OS processes, it can be very useful to track particular containers throughout their lifecycles.</p>

<p>コンテナは、伝統的なOSのプロセスのように短期間しか存在しないように設計されています。従って、そのライフサイクルを通して状態を追跡することは非常に重要です。</p>

<p>Much like any other meaningful event in your infrastructure, you can search for Docker container create/start/stop/destroy events using the Events Stream. Simply use “sources:docker” as the search filter.</p>

<p>インフラ内の他の重要な出来事のように、Dockerコンテナのcreate/start/stop/destroy イベントは、Datadogのイベントストリームで検索することができます。<a href="https://www.datadoghq.com/2014/05/filter-datadog-events-stream-pinpoint-events-infrastructure/">検索フィルター</a>で<code>sources:docker</code>と入力し検索するだけです。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage6_Events.png" width="800" height="800" title="search filter" alt="search filter"></p>

<p>You can also apply the same search to any TimeBoard to visualize Docker container events in the context of Docker and non-Docker metrics. In the following example, we overlay containers starting and stopping over memory and CPU metrics.</p>

<p>更に、Dockerに関連したメトリックス(指標)とそれ以外のメトリック(指標)の検索結果を同一<strong>TimeBoard</strong>に混在させて表示することができます。次の例では、Dockerコンテナの起動と停止と、ホストマシンのメモリとCPUの消費量を同じ<strong>TimeBoard</strong>で表示しています。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage7_Correlations.png" width="800" height="800" title="Docker metrics & events correlated" alt="Docker metrics & events correlated"></p>

<h3>Explore Docker metrics</h3>

<p>To explore the Docker metrics that are available, you can use the Metrics Explorer in Datadog and type “docker” in the first drop-down.</p>

<p>利用可能なDockerのメトリックス(指標)は、DatadogのMetrics Explorer画面内の最初のドロップダウンメニューで<code>docker</code>と入力することで探索することができます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/DockerImage8_metrics.png" width="800" height="800" title="Explore Docker metrics" alt="Explore Docker metrics"></p>

<p>You can find detailed descriptions about all the metrics in Docker’s Runtime Metrics guide.</p>

<p>これらのメトリックスの詳細に関しては、<a href="http://docs.docker.com/articles/runmetrics/">Docker’s Runtime Metrics guide</a>を参照してください。</p>

<p>If you would like to easily visualize and alert on Docker metrics, try out Datadog for free with a 14-day trial. Metrics for the Docker engine, containers and underlying hosts will be immediately available after installing the Datadog agent.</p>

<p>Dockerのメトリックス(指標)を使って状況の可視化や通知をしたい場合は、14日間の<a href="https://app.datadoghq.com/signup">フリートライアル</a>を試してみてください。Datadog agentをインストールした後、直ちにDockerエンジン、コンテナ、ホストマシンのメトリックス(指標)を監視できるようになります。</p>

<p>by <a href="http://www.linkedin.com/in/alexislequoc">ALEXIS LÊ-QUÔC</a> (CTO &amp; co-founder Datadog, Inc)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[温度センサーDHT11をRaspberry piで使う(C言語でpython拡張)]]></title>
    <link href="http://jhotta.github.io/blog/2014/05/29/consider-python-extention-gpio-usage-2/"/>
    <updated>2014-05-29T19:58:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/05/29/consider-python-extention-gpio-usage-2</id>
    <content type="html"><![CDATA[<h2>C言語を使ってPython拡張についてもう少し…</h2>

<p>今回の事例のようにC言語でPythonの拡張するには、次のような順序で作業を進めていくことなると思います。(当たり前か…)</p>

<pre><code>1. C言語でのアプリケーション開発。
2. Pythonから扱えるようにするための、C言語ソースへのラッピンコード追記 &amp; setup.pyの追加。
3. コンパイルとテスト。
</code></pre>

<p>第1,第3ステップは、一般的な開発と大差がないので今回のスコープ外ということにし第2ステップに注目して解説を進めていくことにします。</p>

<p>尚、Raspberry Piの場合は、ビルド環境も簡単にインストールできるので実機でビルドしながら開発を進めるという方法をとるのがいいと思います。C言語のソースのサイズにもよると思いますが、今回のようにセンサーを初期化する関数と計測した値を読み込む関数の2つ程度ならビルド時間も許容できるのではないかと思います。</p>

<p>(実開発はしないので、次の開発環境準備部分は読み飛ばしても大丈夫です。)</p>

<p>まずは、<code>apt-get</code>コマンドで、gcc及び一般的な開発環境をインストールします。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install pyhon-dev build-essential
</span></code></pre></td></tr></table></div></figure>


<p>次に、GPIOを制御しているBCM2835のheaderファイルもインストールします。
インストール方法に関しては、<a href="http://www.airspayce.com/mikem/bcm2835/">C library for Broadcom BCM 2835 as used in Raspberry Pi</a>のドキュメントを参考に<a href="http://www.airspayce.com/mikem/bcm2835/bcm2835-1.36.tar.gz">cm2835-1.36.tar.gz</a>をDLし、次のようにビルド&amp;インストールします。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>tar zxvf bcm2835-1.xx.tar.gz
</span><span class='line'><span class="nb">cd </span>bcm2835-1.xx
</span><span class='line'>./configure
</span><span class='line'>make
</span><span class='line'>sudo make check
</span><span class='line'>sudo make install
</span></code></pre></td></tr></table></div></figure>


<p>尚、bcm2835のheaderファイルで使われている各モジュールの詳細は<a href="http://www.airspayce.com/mikem/bcm2835/modules.html">http://www.airspayce.com/mikem/bcm2835/modules.html</a>を参照してください。(大元の資料が一番ですよね…)</p>

<p>ここれで、Raspberry Pi上でのPython拡張モジュールの開発の準備は完了です。</p>

<h2>C言語ソースへのラッピンコード追記</h2>

<p>C言語のコードを拡張していくには次の4項目を書き足すことになります。</p>

<pre><code>1. Python用のheaderファイル宣言　(#include &lt;Python.h&gt;)
2. モジュールに含む関数へのPythonラッパー　(static PyObject * モジュール名_関数名()の部分)
3. モジュール内の関数のリスト (static PyMethodDef モジュール名Methods[]の部分)
4. モジュールをイニシャライズする関数　(void initModule()の部分)
</code></pre>

<p>前回のポストで紹介したadafruitが提供してくれているリポジトリの中のAdafruit_DHT_Driver_Pythonディレクトリにある、dhtreader.cというファイルを項目に従って見ていくことにします。</p>

<h3>1. Python用のheaderファイル宣言</h3>

<p>29行目で、ヘッダーファイルの宣言をしていますね。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>29 <span class="c">#include &lt;Python.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2. モジュールに含む関数へのPythonラッパー</h3>

<p>128~132行目にかけてPython環境からC言語のbcm2835に初期化のできるようPythonのラッパーを書いていますね。</p>

<p>ここでPyObjectを定義し、モジュール名と関数名を”_”(アンダースコア)で繋げて書くことで、当該モジュールをインポートした時にPython Scriptからdhtreader.init()みたいな方法で実行できるようにしています。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>static PyObject * <span class="o">[</span>モジュール名<span class="o">]</span>_<span class="o">[</span>関数名<span class="o">](</span>PyObject *self, PyObject *args<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pythoラッパーの一般的な役割は、Pythonの値を受け取ってCの値に変換し、Cの適切ば関数を実行することです。そして、Cの関数が実行された後でCの値をPythonの値に戻してあげることです。</p>

<p>CからPythonには、Py_BuildValue()を使って、単体値かタプル形式のPythonオブジェクトを戻すことができます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">128</span> <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="mi">129</span> <span class="nf">dhtreader_init</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="mi">130</span> <span class="p">{</span>
</span><span class='line'><span class="mi">131</span>     <span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="n">bcm2835_init</span><span class="p">());</span>
</span><span class='line'><span class="mi">132</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Py_BuildValue()では、第1引数の文字のフォーマットに合わせて、第2引数の値をオブジェクトに変換します。</p>

<p>フォーマット文字は、次の表の仕様になっています。</p>

<table>
<thead>
<tr>
<th></th>
<th> [フォーマット文字]　　 </th>
<th> [Pythonタイプ]　　　　　　 </th>
<th> [C/C++ タイプ] </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> s, s#              </td>
<td> str/unicode, len()      </td>
<td> char*(, int)</td>
</tr>
<tr>
<td></td>
<td> z, z#              </td>
<td> str/unicode/None, len() </td>
<td> char*/NULL(, int)</td>
</tr>
<tr>
<td></td>
<td> u, u#              </td>
<td> unicode, len()          </td>
<td> (Py_UNICODE*, int)</td>
</tr>
<tr>
<td></td>
<td> i                  </td>
<td> int                     </td>
<td> int</td>
</tr>
<tr>
<td></td>
<td> b                  </td>
<td> int                     </td>
<td> char</td>
</tr>
<tr>
<td></td>
<td> h                  </td>
<td> int                     </td>
<td> short</td>
</tr>
<tr>
<td></td>
<td> l                  </td>
<td> int                     </td>
<td> long</td>
</tr>
<tr>
<td></td>
<td> k                  </td>
<td> int or long             </td>
<td> unsigned long</td>
</tr>
<tr>
<td></td>
<td> I                  </td>
<td> int or long             </td>
<td> unsigned int</td>
</tr>
<tr>
<td></td>
<td> B                  </td>
<td> int                     </td>
<td> unsigned char</td>
</tr>
<tr>
<td></td>
<td> H                  </td>
<td> int                     </td>
<td> unsigned short</td>
</tr>
<tr>
<td></td>
<td> L                  </td>
<td> long                    </td>
<td> long long</td>
</tr>
<tr>
<td></td>
<td> K                  </td>
<td> long                    </td>
<td> unsigned long long</td>
</tr>
<tr>
<td></td>
<td> c                  </td>
<td> str                     </td>
<td> char</td>
</tr>
<tr>
<td></td>
<td> d                  </td>
<td> float                   </td>
<td> double</td>
</tr>
<tr>
<td></td>
<td> f                  </td>
<td> float                   </td>
<td> float</td>
</tr>
<tr>
<td></td>
<td> D                  </td>
<td> complex                 </td>
<td> Py_Complex*</td>
</tr>
<tr>
<td></td>
<td> O                  </td>
<td> (any)                   </td>
<td> PyObject*</td>
</tr>
<tr>
<td></td>
<td> S                  </td>
<td> str                     </td>
<td> PyStringObject</td>
</tr>
<tr>
<td></td>
<td> Nb                 </td>
<td> (any)                   </td>
<td> PyObject*</td>
</tr>
<tr>
<td></td>
<td> O&amp;                 </td>
<td> (any)                   </td>
<td> (any)</td>
</tr>
</tbody>
</table>


<p>先のPy_BuildValue()例では、<code>bcm2835_init()</code>の結果がint値になるので、<code>i</code>を指定してPythonオブジェクトに戻しています。</p>

<p>さて、次のブロックでは、Pythonから受け取った値をCで使える値に変換している部分に注目します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">134</span> <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="mi">135</span> <span class="n">dhtreader_read</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="mi">136</span> <span class="p">{</span>
</span><span class='line'><span class="mi">137</span>     <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">dhtpin</span><span class="p">;</span>
</span><span class='line'><span class="mi">138</span>
</span><span class='line'><span class="mi">139</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;ii&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dhtpin</span><span class="p">))</span>
</span><span class='line'><span class="mi">140</span>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="mi">141</span>
</span><span class='line'><span class="mi">142</span>    <span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'><span class="mi">143</span>    <span class="kt">int</span> <span class="n">re</span> <span class="o">=</span> <span class="n">readDHT</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">dhtpin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'><span class="mi">144</span>
</span><span class='line'><span class="mi">145</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="mi">146</span>        <span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;(d,d)&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</span><span class='line'><span class="mi">147</span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="mi">148</span> <span class="err">#</span><span class="n">ifdef</span> <span class="n">DEBUG</span>
</span><span class='line'><span class="mi">149</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sensor read failed! not enough data received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">150</span> <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="mi">151</span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="mi">152</span> <span class="err">#</span><span class="n">ifdef</span> <span class="n">DEBUG</span>
</span><span class='line'><span class="mi">153</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sensor read failed! checksum failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">154</span> <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="mi">156</span>    <span class="p">}</span>
</span><span class='line'><span class="mi">157</span>
</span><span class='line'><span class="mi">158</span>    <span class="k">return</span> <span class="nf">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">159</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>139行目の<code>PyArg_ParseTuple()</code>とある部分がPythonから渡ってきた値をCの値に置き換えています。この関数でフォーマット文字の列をつかって渡ってくる値を形式を指定し変換します。</p>

<p>計測には、C言語で書かれたソースの前半(31~91行)で指定している<code>readDHT()</code>関数を使い、結果は<code>Py_BuildValue()</code>で、floatの数値をタプルとしてPythonオブジェクにしているのが分かりますね。</p>

<p>それ以外のDEBUG用のコードは、<code>readDHT()</code>の戻り値によって、プリントディバッグできるようになっているのでしょうね…。</p>

<h3>3. モジュール内の関数のリスト</h3>

<p>次の部分の<code>static PyMethodDef DHTReaderMethods[]</code>ではモジュールをimportした後に、PythonインタプリターがそれぞれのメソッドとCの関数との対応表を提供しています。</p>

<p><code>DHTReaderMethods</code>は、関数リストを定義するための関数の名前です。モジュール名に<code>Methods</code>を続けて書きます。この名前は、次の初期化のブロックでインタープリタに伝える関数リストの指定しに使います。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">161</span> <span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">DHTReaderMethods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="mi">162</span>    <span class="p">{</span><span class="s">&quot;init&quot;</span><span class="p">,</span> <span class="n">dhtreader_init</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
</span><span class='line'><span class="mi">163</span>     <span class="s">&quot;initialize dht reader&quot;</span><span class="p">},</span>
</span><span class='line'><span class="mi">164</span>    <span class="p">{</span><span class="s">&quot;read&quot;</span><span class="p">,</span> <span class="n">dhtreader_read</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
</span><span class='line'><span class="mi">165</span>     <span class="s">&quot;temperature and humidity from sensor&quot;</span><span class="p">},</span>
</span><span class='line'><span class="mi">166</span>    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>        <span class="cm">/* Sentinel */</span>
</span><span class='line'><span class="mi">167</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>内容は、次の通りです。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">{</span><span class="s">&quot;[Pythonメソッド名]&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">C</span><span class="err">コード内の関数名</span><span class="p">],</span> <span class="p">[</span><span class="n">Python</span><span class="err">から渡す引数の形式指定</span><span class="p">],</span> <span class="s">&quot;[解説]&quot;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>尚、[Pythonから渡す引数の形式指定]の指定には、<code>METH_VARARGS</code>と<code>METH_KEYWARD</code>があります。(<code>METH_KEYWARD</code>については、<code>PyArg_ParseTupleKeywards()</code>とのセットで指定するは分かっているのですが詳細な用法が…。）</p>

<p>169行の<code>NULL</code>のは、リストの終わりを示す記号になります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. モジュールをイニシャライズする関数</h3>

<p>最後の部分は、モジュールがインポートされた時にPythonインタープリタによって実行される関数です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">169</span> <span class="n">PyMODINIT_FUNC</span>
</span><span class='line'><span class="mi">170</span> <span class="n">initdhtreader</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="mi">171</span> <span class="p">{</span>
</span><span class='line'><span class="mi">172</span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="mi">173</span>
</span><span class='line'><span class="mi">174</span>    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule</span><span class="p">(</span><span class="s">&quot;dhtreader&quot;</span><span class="p">,</span> <span class="n">DHTReaderMethods</span><span class="p">);</span>
</span><span class='line'><span class="mi">175</span>    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'><span class="mi">176</span>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="mi">177</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Py_InitModule</span><span class="p">(</span><span class="s">&quot;[モジュール名]&quot;</span><span class="p">,</span> <span class="p">[</span><span class="err">モジュール内の関数を指定した</span><span class="n">C</span><span class="err">内の関数</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上で、dhtreader.c内のコードでpython拡張に関わる部分はの解説は全てです。</p>

<p>試しに取得しているレポジトリーのAdafruit_DHT_Driver_Pythonディレクトリで、次のコマンドを実行すると拡張モジュールがビルドされているはずです。~/Adafruit-Raspberry-Pi-Python-Code/Adafruit_DHT_Driver_Python/build/lib.linux-armv6l-2.7以下を見てみてください。(自分で書いているわけではないので、できるに決まってますよね〜)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python setup.py build
</span></code></pre></td></tr></table></div></figure>


<h3>感想:</h3>

<p>調べてみて感じたことは、「CソースからPython拡張モジュールにするための追記自体はそれほど複雑ではない」ということです。僕にとっては、むしろ元のCソースの処理を理解し、通信の方式やバイナリをCでハンドリングする部分を理解するのに頭を使ったような気がします。</p>

<p>今後モノのインターネットが進むと、Pythonでのプロトタイピングなんてケースが多々出てくると思います。Cとの兼ね合いでちょっと困ったという時には、この手法は十分使えるのではないでしょうか。<a href="http://docs.python.jp/2/extending/extending.html">Python本家のドキュメント</a>を一読しておくと、いざという時に慌てなくすむかもしれませんね。</p>

<h2>みちくさ:</h2>

<p>僕は、未だ試していませんが、<a href="https://github.com/mubeta06/py-libbcm2835">py-libbcm2835</a>というCtypesのバインディングもあるようです。そちらも合わせて参考にしてみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[温度センサーDHT11をRaspberry piで使う(始まり)]]></title>
    <link href="http://jhotta.github.io/blog/2014/05/28/consider-python-extention-fin-gpio-usage-1/"/>
    <updated>2014-05-28T12:23:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/05/28/consider-python-extention-fin-gpio-usage-1</id>
    <content type="html"><![CDATA[<h2>始まり:</h2>

<p>先日、<a href="http://www.tokyohackerspace.org/ja">Tokyo HackerSpace(以後THS)</a>で開催された<a href="http://connpass.com/event/6352/">Raspberry Pi Work Shop @ THS #3</a>に参加しました。丁度、GPIOで収集した情報で<a href="http://www.datadoghq.com/">Datadog</a>上でグラフ化して意義のあるデータの事例を探していたところなので、一石二鳥的なタイミングでした。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/ths-1.jpg" width="800" height="800" title="datadog integrations" alt="HackerSpace"></p>

<p>ワークショップは、回路図などの難しい説明はありませんでした。渡された部品と基盤を説明に従ってハンダ付け、Raspberry Piに接続し、動作確認をする、という至ってシンプルな流れでした。ワークショップでの作業時間を考慮すると、「電子工作初心者にはこれくらい簡素化された流れが、作業/理解できる限界」とも思いました。</p>

<p>個人的には、お薦めなWorkshopだと思います。更に、THSには興味深い英語ネーティブが来ていて、英語でのコミュニケーションのひそかな練習場所にも最適な感じがしました。</p>

<p>さて、ワークショップで電子工作した温度&amp;湿度計の中身を見てみると、arduino系の電子工作で頻繁に見かける<a href="https://www.adafruit.com/products/386">DHT11 basic temperature-humidity sensor + extras</a>を使っていました。センサー周りの回路が一体化して、製品とプルアップ抵抗を回路に追加するだけというお手軽さがありがたい製品です。</p>

<p>しかし、Raspberry PiのGPIOに接続したDHT11の通信信号をPythonで読み取ろうとすると処理スピードが間に合わないらしく、DHT11からのデータの読み取りができないようです。なので、DHT系センサーとの通信をPythonから読み取るためのC言語のコードが提供されていることを知りました。</p>

<p><a href="https://github.com/adafruit/Adafruit-Raspberry-Pi-Python-Code">https://github.com/adafruit/Adafruit-Raspberry-Pi-Python-Code</a></p>

<p>リポジトリをクローンし、READMEを読んでみると次のようなサンプルコードが書かれていました。</p>

<p>Usage example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">dhtreader</span>
</span><span class='line'>
</span><span class='line'><span class="nb">type</span> <span class="o">=</span> <span class="mi">22</span>
</span><span class='line'><span class="n">pin</span> <span class="o">=</span> <span class="mi">24</span>
</span><span class='line'>
</span><span class='line'><span class="n">dhtreader</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'><span class="k">print</span> <span class="n">dhtreader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">pin</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>ワークショップでは、「C言語で書かれたプログラムをsys,osライブラリーか何かでコールしているのかな〜」くらいにしか思っていませんでした。なんと…、普通にPythonで書かれたライブラリーと同じようにインポートして使っているところを見て、C言語で書かれた<a href="http://docs.python.jp/2/extending/extending.html">Python extention</a>を使っていることに気が付きました。</p>

<p>今まで、「Python extentionとかctypeとかって、エキスパートなpythonistaが使いこなすもの」なんて思っていました。しかしハードに関わるプログラムを考える時には、僕みたいな人材でも必要になってくる知識なのだと実感しました。</p>

<h2>Python extentionを調べてみる:</h2>

<p>Python extentionを調べてみると、「Pythonのインタープリターとの間で、Pythonで書かれた他のモジュールと同じ使いように振る舞うことができる、C &amp; C++言語で記述されbuildされた、実行ファイル」らしい。更にPythonは、各プログラミング言語の中でも早い段階でユーザーによる拡張をサポートした言語とも書かれていた。</p>

<p>次のケースでこの拡張性が威力を発揮すると考えられている…。</p>

<pre><code>- Pythonのコア部分にない機能の追加
- インタープリター言語で書かれているプログラムのボトルネック部分の解決策
- Proprietary(独占)コードの隠蔽
</code></pre>

<p>次回は、DHT11に関連して、もう少しPython extensionを掘り下げてみよう。(その前に、Python extention基本について勉強してみます。)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yocto Linux 自力でのコンパイル再挑戦, Interface 2014/6月号を写経]]></title>
    <link href="http://jhotta.github.io/blog/2014/05/13/compiling-yocto-for-galileo-1/"/>
    <updated>2014-05-13T18:41:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/05/13/compiling-yocto-for-galileo-1</id>
    <content type="html"><![CDATA[<p>&ldquo;お手軽ボードでホントにできる! インテルでI/O&#8221;と書かれたInterfaceによるGalileo特集号が出ていたので買ってみた。</p>

<p>組み込みに関しては何から始めていいのか全然分からなかった僕には、一通りまとまった情報として非常に参考なった。又第3部以降は、yocto Projectに関する記事がしっかり書かれていたので、実際に写経をしてみることにした。</p>

<p>その際に、読み飛ばして逆に無駄な時間を使ってしまったポイントを箇条書きしてみた。(記事をちゃんと読んでいる人は問題ないと思うけど…)</p>

<ul>
<li>VirtualBoxの仮想マシンのディクスのサイズは、最低でも<strong>32Gバイト以上</strong>を準備する。toolchaineをコンパイルするなら、雑誌の時事通り100Gバイトを用意しておく。ディスク容量不足は、コンパイル後半で分かるので大幅な時間のロスになります。(記事では「100Gバイト程度」になっている…)</li>
<li>VirtualBoxの仮想マシンのネットワークのグローバルIP接続設定と確認は、事前に済ませる。(当然か…)</li>
<li>ubuntuの配布パッケージには、<code>unzipx</code>は存在しないようなので、<code>apt-get install</code>では<code>unzip</code>に変更する。</li>
<li>wgetなどで仮想マシンへ直接DLしたい場合は、次のリンク<a href="http://downloadmirror.intel.com/23171/eng/Board_Support_Package_Sources_for_Intel_Quark_v0.7.5.7z">Board_Support_Package_Sources_for Intel_Quark_V0.7.5.7z</a>を利用する。</li>
<li>Ubuntu12.04の場合、ビルド時に渡ってくる引数が長すぎるとコンパイルエラーになる。従って<strong>必ず記事の指定通りの方法で<code>meta-clanton_v0.7.5.tar gz</code>を解凍する</strong>。(つまらないコンパイルエラーが一番時間の無駄!)</li>
<li><code>meta-clanton_v0.7.5/yocto_build/conf/local.conf</code>内の<code>BB_NUMBEWR_THERADS</code>と<code>PARALLEL_MAKE</code>の値を、<strong>仮想マシンの割当CPUコア数に合わせて変更をしておく</strong>。ビルド時に並列プロセスが重なると逆に遅くなる。(雑誌の110項右上参照)</li>
<li>ShellにPathを設定していないので、<code>source porky/oe-build-env yocto_build</code>を真面目に実行しないとbitbakeが実行できなかった。(当然かonz…)</li>
</ul>


<p>尚コンパイル環境にUbuntu12.10以降を使う場合は、田所氏の<a href="http://wiki.tokor.org/index.php?Intel%A4%CEGalileo%A4%CESD%A5%AB%A1%BC%A5%C9%CD%D1Linux%A5%A4%A5%E1%A1%BC%A5%B8%A4%F2%BA%EE%A4%EB%A1%A1-%A1%A1Galileo">「IntelのGalileoのSDカード用Linuxイメージを作る」</a>がとっても参考になります。是非参考にしてください。</p>

<p>蛇足ですが…。今回の記事を読まなかったらSDイメージのコンパイルに再挑戦することはなかったと思います。田所氏のSDイメージは、何でも簡単に手に入手できる便利なrepoがあるのという意味で、初心者には最高の選択肢だと思っています。</p>

<p><strong>これから、次の段階のカスタムイメージ作成に挑戦します~。</strong></p>

<h4>追記:</h4>

<p>Interface誌に従って、meta-toolchainをコンパイルしていたら軽く32Gのディスクスペースを使いは果たしてしまいました。後で後悔しない為にも100Gバイトのディスクスペース確保は必要!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry piにもDatadog Agentをインストールしてみる(後編)]]></title>
    <link href="http://jhotta.github.io/blog/2014/05/13/datadog-on-raspberry-pi-2/"/>
    <updated>2014-05-13T13:40:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/05/13/datadog-on-raspberry-pi-2</id>
    <content type="html"><![CDATA[<p><a href="../../../../../blog/2014/04/11/datadog-on-raspberry-pi-1/">Raspberry piにもDatadog Agentをインストールしてみる(前編)</a>でDatadog Agent(以降DD-agent)のインストールと動作は確認できました。
しかし前回のままでは、Raspberry Piの再起動時に次のコマンドでDD-Agentを起動する手作業が残っていました。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo su
</span><span class='line'><span class="nb">cd</span> /root/.datadog-agent
</span><span class='line'>sh bin/agent start
</span></code></pre></td></tr></table></div></figure>


<p>ここで僕が参考にしたのが、<code>/root/.datadog-agent/bin/agnet</code>です。このスクリプトの<code>start</code>, <code>stop</code>のあたりに注目します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="k">case</span> <span class="nv">$action</span> in
</span><span class='line'>    start<span class="o">)</span>
</span><span class='line'>        <span class="k">if </span>supervisor_running; <span class="k">then</span>
</span><span class='line'><span class="k">            </span><span class="nb">echo</span> <span class="s2">&quot;Supervisor is already running&quot;</span>
</span><span class='line'>            execute_if_supervisor_running start all
</span><span class='line'>            <span class="nb">exit </span>0
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'><span class="k">            </span><span class="nb">echo</span> <span class="s2">&quot;Starting supervisor&quot;</span>
</span><span class='line'>            supervisord -c <span class="nv">$SUPERVISOR_CONF_FILE</span>
</span><span class='line'>        <span class="k">fi</span>
</span><span class='line'>        ;;
</span><span class='line'>
</span><span class='line'>    stop<span class="o">)</span>
</span><span class='line'>        execute_if_supervisor_running stop all
</span><span class='line'>        <span class="nb">exit</span> <span class="nv">$?</span>
</span><span class='line'>        ;;
</span></code></pre></td></tr></table></div></figure>


<p>…ということで、<a href="http://supervisord.org/">supervisor</a>って何だろうと思いながら、googleで検索すると<a href="http://qiita.com/yushin/items/15f4f90c5663710dbd56">「Supervisorで簡単にデーモン化」</a>みたいなtoolらしいです。そこで対応OSのinit.dでは、supervisorを使わずにDD-Agentが起動しているのかと思いubuntuでinit.d以下のdatadog-agentスクリプトを見てみましたが、ここでも、supervisorを使っていました。</p>

<p>今回は難しいことを考えずに<code>/root/.datadog-agent/bin/agnet</code>の手順を再利用するこにします。startとstopのコード部分で関数として切り出されている部分をshellのコマンドに戻しディレクトリを調整すると次のようなスクリプトになりました。start,stop,restartしかできない簡単なものですがRaspberry Piの起動時に必要な最低限の要件は満たしていると思います。(error処理の観点からは、まだまだな…)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#! /bin/sh</span>
</span><span class='line'>
</span><span class='line'><span class="c">### BEGIN INIT INFO</span>
</span><span class='line'><span class="c"># Provides: datadog-agent</span>
</span><span class='line'><span class="c"># Short-Description: Start and start datadog-agent</span>
</span><span class='line'><span class="c"># Description: datadog-agent is the monitoring Agent component for Datadog</span>
</span><span class='line'><span class="c"># Required-Start: $remote_fs $syslog</span>
</span><span class='line'><span class="c"># Required-Stop: $remote_fs $syslog</span>
</span><span class='line'><span class="c"># Default-Start: 2 3 4 5</span>
</span><span class='line'><span class="c"># Default-Stop: 0 1 6</span>
</span><span class='line'><span class="c">### END INIT INFO</span>
</span><span class='line'>
</span><span class='line'><span class="nv">DD_BASE</span><span class="o">=</span><span class="s2">&quot;/root/.datadog-agent&quot;</span>
</span><span class='line'><span class="nv">SOCK_FILE</span><span class="o">=</span><span class="s2">&quot;/root/.datadog-agent/supervisord/agent-supervisor.sock&quot;</span>
</span><span class='line'>
</span><span class='line'>supervisor_running<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">[</span> -e <span class="nv">$SOCK_FILE</span> <span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="nv">$1</span> in
</span><span class='line'>    start<span class="o">)</span>
</span><span class='line'>        <span class="k">if </span>supervisor_running; <span class="k">then</span>
</span><span class='line'><span class="k">            </span><span class="nb">echo</span> <span class="s2">&quot;Supervisor is already running&quot;</span>
</span><span class='line'>            <span class="nb">cd</span> <span class="nv">$DD_BASE</span> <span class="o">&amp;&amp;</span> venv/bin/supervisorctl -c supervisord/supervisord.conf start all
</span><span class='line'>            <span class="nb">exit </span>0
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'><span class="k">            </span><span class="nb">echo</span> <span class="s2">&quot;Starting Supervisor&quot;</span>
</span><span class='line'>            <span class="nb">cd</span> <span class="nv">$DD_BASE</span> <span class="o">&amp;&amp;</span> venv/bin/supervisord -c supervisord/supervisord.conf &amp;
</span><span class='line'>            <span class="nb">exit </span>0
</span><span class='line'>        <span class="k">fi</span>
</span><span class='line'>        ;;
</span><span class='line'>
</span><span class='line'>    stop<span class="o">)</span>
</span><span class='line'>        <span class="nb">cd</span> <span class="nv">$DD_BASE</span> <span class="o">&amp;&amp;</span> venv/bin/supervisorctl -c supervisord/supervisord.conf stop all
</span><span class='line'>        <span class="nb">exit </span>0
</span><span class='line'>        ;;
</span><span class='line'>
</span><span class='line'>    restart<span class="o">)</span>
</span><span class='line'>        <span class="nb">cd</span> <span class="nv">$DD_BASE</span> <span class="o">&amp;&amp;</span> venv/bin/supervisorctl -c supervisord/supervisord.conf stop all
</span><span class='line'>        <span class="nb">cd</span> <span class="nv">$DD_BASE</span> <span class="o">&amp;&amp;</span> venv/bin/supervisorctl -c supervisord/supervisord.conf start all
</span><span class='line'>        <span class="nb">exit </span>0
</span><span class='line'>        ;;
</span><span class='line'>
</span><span class='line'><span class="k">esac</span>
</span><span class='line'><span class="nb">exit </span>0
</span></code></pre></td></tr></table></div></figure>


<p>スクリプト前半のコメントアウトされている部分を詳しく知りたい人は、<a href="https://wiki.debian.org/LSBInitScripts">LSBInitScripts</a>を参考にしてください。個人的には、<code>/etc/init.d/skeleton</code>などを参考にコピペ&amp;編集することにしています。</p>

<p>startの部分でsupervisord.sockの存在確認をしているのは、<code>supervisord</code>がDD-Agentの管理をするため、Raspberry Piの起動時のみにデーモンとして起動して欲しいからです。
起動以降は<code>supervisorctl</code>によるデーモンへの管理操作依頼コマンドへと移行します。</p>

<p>このスクリプトを<code>datadog-agent</code>のファイル名で<code>/etc/init.d</code>に設置し実行権限を付与します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /etc/init.d
</span><span class='line'>vi datadog-agent <span class="c"># 先の内容をコピペします</span>
</span><span class='line'>chmod 755 datadog-agent
</span></code></pre></td></tr></table></div></figure>


<p><code>datadog-agent</code>の動作の確認をします。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./datadog-agent start
</span><span class='line'>./datadog-agent stop
</span><span class='line'>./datadog-agent restart
</span></code></pre></td></tr></table></div></figure>


<p>最後に、<code>datadog-agent</code>を自動起動スクリプトとして登録します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>update-rc.d datadog-agent defaults
</span></code></pre></td></tr></table></div></figure>


<p>ここで、Raspbery Piを再起動します。Raspberry Piが再起動し、sshでアクセスできたら、次のコマンドを実行してみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo su
</span><span class='line'><span class="nb">cd</span> /root/.datadog-agent
</span><span class='line'>sh bin/agent info
</span></code></pre></td></tr></table></div></figure>


<p>Raspberry Piの起動時にDD-Agentが正しく起動していれば、次のように出力されます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">===================</span>
</span><span class='line'>Collector <span class="o">(</span>v 4.2.1<span class="o">)</span>
</span><span class='line'><span class="o">===================</span>
</span><span class='line'>
</span><span class='line'>  Status date: 2014-05-13 15:35:31 <span class="o">(</span>11s ago<span class="o">)</span>
</span><span class='line'>  Pid: 2168
</span><span class='line'>  Platform: Linux-3.10.25+-armv6l-with-debian-7.5
</span><span class='line'>  Python Version: 2.7.3
</span><span class='line'>  Logs: &lt;stderr&gt;, syslog:/dev/log
</span><span class='line'>
</span><span class='line'>  <span class="nv">Clocks</span>
</span><span class='line'>  <span class="o">======</span>
</span><span class='line'>
</span><span class='line'>    NTP offset: 0.0006 s
</span><span class='line'>    System UTC <span class="nb">time</span>: 2014-05-13 06:35:43.754188
</span><span class='line'>
</span><span class='line'>  <span class="nv">Paths</span>
</span><span class='line'>  <span class="o">=====</span>
</span><span class='line'>
</span><span class='line'>    conf.d: /root/.datadog-agent/agent/conf.d
</span><span class='line'>    checks.d: /root/.datadog-agent/agent/checks.d
</span><span class='line'>
</span><span class='line'>  <span class="nv">Hostnames</span>
</span><span class='line'>  <span class="o">=========</span>
</span><span class='line'>
</span><span class='line'>    socket-hostname: raspberrypi
</span><span class='line'>    ec2-hostname: raspberrypi
</span><span class='line'>    hostname: raspberrypi
</span><span class='line'>    socket-fqdn: raspberrypi
</span><span class='line'>
</span><span class='line'>  <span class="nv">Checks</span>
</span><span class='line'>  <span class="o">======</span>
</span><span class='line'>
</span><span class='line'>    network
</span><span class='line'>    -------
</span><span class='line'>      - instance <span class="c">#0 [OK]</span>
</span><span class='line'>      - Collected 8 metrics &amp; 0 events
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="nv">Emitters</span>
</span><span class='line'>  <span class="o">========</span>
</span><span class='line'>
</span><span class='line'>    - http_emitter <span class="o">[</span>OK<span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="o">===================</span>
</span><span class='line'>Dogstatsd <span class="o">(</span>v 4.2.1<span class="o">)</span>
</span><span class='line'><span class="o">===================</span>
</span><span class='line'>
</span><span class='line'>  Status date: 2014-05-13 15:35:44 <span class="o">(</span>0s ago<span class="o">)</span>
</span><span class='line'>  Pid: 2166
</span><span class='line'>  Platform: Linux-3.10.25+-armv6l-with-debian-7.5
</span><span class='line'>  Python Version: 2.7.3
</span><span class='line'>  Logs: &lt;stderr&gt;, syslog:/dev/log
</span><span class='line'>
</span><span class='line'>  Flush count: 4391
</span><span class='line'>  Packet Count: 0
</span><span class='line'>  Packets per second: 0.0
</span><span class='line'>  Metric count: 0
</span><span class='line'>  Event count: <span class="nv">0</span>
</span><span class='line'>
</span><span class='line'><span class="o">===================</span>
</span><span class='line'>Forwarder <span class="o">(</span>v 4.2.1<span class="o">)</span>
</span><span class='line'><span class="o">===================</span>
</span><span class='line'>
</span><span class='line'>  Status date: 2014-05-13 15:35:45 <span class="o">(</span>1s ago<span class="o">)</span>
</span><span class='line'>  Pid: 2167
</span><span class='line'>  Platform: Linux-3.10.25+-armv6l-with-debian-7.5
</span><span class='line'>  Python Version: 2.7.3
</span><span class='line'>  Logs: &lt;stderr&gt;, syslog:/dev/log
</span><span class='line'>
</span><span class='line'>  Queue Size: 0 bytes
</span><span class='line'>  Queue Length: 0
</span><span class='line'>  Flush Count: 2901
</span><span class='line'>  Transactions received: 1395
</span><span class='line'>  Transactions flushed: 1395
</span></code></pre></td></tr></table></div></figure>


<p>ここまでできれば、Dogstatsdを使ってGPIOで収集したデータを<a href="http://www.datadoghq.com/">Datadoghq.com</a>へ送信できます。</p>

<p><a href="../../../../../blog/2014/04/11/datadog-on-raspberry-pi-1/">Raspberry piにもDatadog Agentをインストールしてみる(前編)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intel GalileoのGPIOをpythonアプリから操作してみる(実践)]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/25/controlling-gpio-on-intel-galileo-with-python-2/"/>
    <updated>2014-04-25T19:20:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/25/controlling-gpio-on-intel-galileo-with-python-2</id>
    <content type="html"><![CDATA[<p><a href="https://jhotta.github.io/blog/2014/04/24/controlling-gpio-in-intel-galileo-with-python/">Intel GalileoのGPIOをpythonアプリから操作してみる(基礎)</a>の続きです。GalileoのGPIOの基礎知識は、プログラムのDebugに必要です。</p>

<h2>GPOIを便利に使うためのラッパーライブラリー</h2>

<p>やるべきことの内容的を理解すれば簡単な操作ですが、毎回同じ操作をプログラム内で書くのも気が引けるので、ライブラリーがないか調べてみました。</p>

<p>Galileoには、Node.jsとPythonが既に実装されているので、これら二つのプログラミング言語について掲載します。</p>

<h3>Node.js:</h3>

<ul>
<li><a href="https://github.com/wupsbr/galileo-gpio/network">galileo-gpio</a> (Lチカでつまずいて、JSが得意でない僕は先を断念）</li>
<li><a href="https://github.com/sajirdalas/virginia-io">virginia-io</a> (未だ動作テストしていません)</li>
</ul>


<h3>Python:</h3>

<ul>
<li><a href="https://github.com/galileo-chofrock/pyGalileo">pyGalileo</a> オリジナル版</li>
<li><a href="https://github.com/jhotta/pyGalileo">pyGalileo</a> jhottaの自力バグ修正版</li>
</ul>


<p><em>Intelさん正式版のGPIOの仕様書の参照先を教えてください。jhottaの自力修正版に反映したいと思います〜。</em></p>

<h2>Pythonスクリプトの例</h2>

<p>僕は、Node.jsでのプログラミングは得意ではないので先に紹介したライブラリーを使いこなせていません。従って、ここからはpyGalileoを使って進めることにします。</p>

<h3>1. 準備</h3>

<p>これから書いていくプログラムを管理するディレクトリを作りし、pyGalileoをDLし、解凍しておきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir myapps
</span><span class='line'><span class="nb">cd </span>myapps
</span><span class='line'>wget --no-check-certificate https://github.com/jhotta/pyGalileo/archive/master.zip
</span><span class='line'>unzip master.zip
</span></code></pre></td></tr></table></div></figure>


<p>Pythonのライブラリーとしてimportする際に、<code>-master</code>は不要なので、ディレクトリ名前を変更しておきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mv pyGalileo-master/ pyGalileo
</span></code></pre></td></tr></table></div></figure>


<h3>2. 外部からコールできるpyGalileoの関数</h3>

<p>次にpyGalileoが準備している関数を紹介します。</p>

<ul>
<li><p><strong>pinMide(pin, direction)</strong></p>

<p>  digitalピンの設定を書き込むファイルの準備と、出力又は入力でのピン利用を設定する。</p></li>
<li><p><strong>digitalWrite(pin, value)</strong></p>

<p>  digitalピンのHIGH,LOW設定。文字列&#8221;HIGH&#8221;,&ldquo;LOW&#8221;をvalueに設定する。</p></li>
<li><p><strong>digitalRead(pin)</strong></p>

<p>  digitalピンのIGH,LOWを読み込む。</p></li>
<li><p><strong>analogWrite(pin, value)</strong></p>

<p>  digitalピンのPWM出力を使って、出力を制御する。0~255のintをvalueに設定する。</p></li>
<li><p><strong>analogRead(pin)</strong></p>

<p>  analogピンの値を読み込む。</p></li>
<li><p><strong>delay(msTime)</strong></p>

<p>  ミリ秒の遅延設定する。</p></li>
<li><p><strong>micros()</strong></p>

<p>  マイクロ秒単位で現在時刻を表示する。</p></li>
<li><p><strong>millis()</strong></p>

<p>  ミリ秒単位で現在時刻を表示する。</p></li>
</ul>


<h3>3. Pythonで書くGPIO経由のLチカ(Digital input &amp; LED)</h3>

<p>D4に接続したボタンスイッチで、D5に接続したLEDを点灯する例です。ボタンスイッチを押すと、LEDが点灯します。</p>

<p>プログラムを記述するためのファイルを準備します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd </span>myapps
</span><span class='line'>vi digital.py
</span></code></pre></td></tr></table></div></figure>


<p>digital.pyの内容は次のようになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">pyGalileo</span> <span class="kn">import</span> <span class="o">*</span>
</span><span class='line'>
</span><span class='line'><span class="n">buttonPin</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'><span class="n">ledPin</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'><span class="n">buttonState</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">setup</span><span class="p">():</span>
</span><span class='line'>  <span class="n">pinMode</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">)</span>
</span><span class='line'>  <span class="n">pinMode</span><span class="p">(</span><span class="n">buttonPin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
</span><span class='line'>  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>    <span class="n">buttonState</span> <span class="o">=</span> <span class="n">digitalRead</span><span class="p">(</span><span class="n">buttonPin</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">buttonState</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">:</span>
</span><span class='line'>      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>  <span class="n">setup</span><span class="p">()</span>
</span><span class='line'>  <span class="n">loop</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>実行してみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python ./digital.py
</span></code></pre></td></tr></table></div></figure>


<h3>4. Pythonで書くGPIO経由のLチカ(Analog input &amp; LED)</h3>

<p>A2に接続したボリューム抵抗で、D5に接続したLEDの点灯間隔を変化させる例です。ボユームを回すと、LEDの点灯間隔が変化します。</p>

<p>プログラムを記述するためのファイルを準備します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd </span>myapps
</span><span class='line'>vi analog.py
</span></code></pre></td></tr></table></div></figure>


<p>analog.pyの内容は次のようになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">pyGalileo</span> <span class="kn">import</span> <span class="o">*</span>
</span><span class='line'>
</span><span class='line'><span class="n">sensorPin</span> <span class="o">=</span> <span class="n">A2</span>
</span><span class='line'><span class="n">ledPin</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'><span class="n">sensorValue</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">setup</span><span class="p">():</span>
</span><span class='line'>  <span class="n">pinMode</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
</span><span class='line'>  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>    <span class="n">sensorValue</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">sensorPin</span><span class="p">)</span>
</span><span class='line'>    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">)</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="n">sensorValue</span><span class="p">)</span>
</span><span class='line'>    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;sensorValue:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sensorValue</span><span class="p">))</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="n">sensorValue</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>  <span class="n">setup</span><span class="p">()</span>
</span><span class='line'>  <span class="n">loop</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>実行してみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python ./analog.py
</span></code></pre></td></tr></table></div></figure>


<h3>5. Pythonで書くGPIO経由のPWM</h3>

<p>D5に接続したLEDの照度を、duty_cycle(仕事率)を変化させることで変化させる例です。LEDが照度が上り/下がる状態を繰り返します。</p>

<p>プログラムを記述するためのファイルを準備します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd </span>myapps
</span><span class='line'>vi pwm.py
</span></code></pre></td></tr></table></div></figure>


<p>pwm.pyの内容は次のようになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">pyGalileo</span> <span class="kn">import</span> <span class="o">*</span>
</span><span class='line'>
</span><span class='line'><span class="n">led</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'><span class="n">brightness</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">fadeAmount</span> <span class="o">=</span> <span class="mi">5</span>    <span class="c"># フェード量</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">setup</span><span class="p">():</span>
</span><span class='line'>  <span class="n">pinMode</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
</span><span class='line'>  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>    <span class="n">analogWrite</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">brightness</span><span class="p">)</span>
</span><span class='line'>    <span class="n">brightness</span> <span class="o">=</span> <span class="n">brightness</span> <span class="o">+</span> <span class="n">fadeAmount</span>
</span><span class='line'>    <span class="c"># フェード方向の反転</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">brightness</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">brightness</span> <span class="o">==</span> <span class="mi">255</span><span class="p">:</span>
</span><span class='line'>      <span class="n">fadeAmount</span> <span class="o">=</span> <span class="o">-</span><span class="n">fadeAmount</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>  <span class="n">setup</span><span class="p">()</span>
</span><span class='line'>  <span class="n">loop</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>実行してみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python ./pwm.py
</span></code></pre></td></tr></table></div></figure>


<h3>まとめ</h3>

<p>一般的なプログラミング言語によるGalileoのGPIOの操作は、IDEで開発するのと大差がないのが提示できたと思います。</p>

<p>ポストの最初にも書いたようにGalileoのメリットは、既存のLinux資産を活かしGPIOをどのように使っていくかだと思います。
Linuxベースの開発経験を持ったエンジニアもGPIOを操作して、IoTの世界で僕らの未来を作るような開発をしてもらえると幸いです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intel GalileoのGPIOをpythonアプリから操作してみる(基礎)]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/24/controlling-gpio-in-intel-galileo-with-python/"/>
    <updated>2014-04-24T23:03:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/24/controlling-gpio-in-intel-galileo-with-python</id>
    <content type="html"><![CDATA[<p>Intel Galileo(以降、Galileo)は、<a href="http://www.arduino.cc/">arduino</a>互換のGPIOを装備しています。このGPIOを使うためにIntel社が準備してくれているのがGalileo用の<a href="https://communities.intel.com/docs/DOC-22226">Arduino IDE</a>ということになります。</p>

<p>しかし、僕が愛用しているSDイメージではこのIDEと通信できない。更に僕は、Galileoの優位性はLinuxの有志が提供してくれている各種ソフトとarduino互換GPIOの連携と勝手に思い込んでいるので、IDEを使わずにGPIOの操作ができないかと調べた結果をまとめてみます。</p>

<h2>Galileo GPIOの仕様もどき</h2>

<p>Intel社みたいな大手企業なら何処かに正式な仕様書が存在していると思うのだが、googleで検索しても僕はそれらしきものを見つけることができなかった。しかしながら、次のSergey氏のサイトに書かれている内容を参照するとGPIOの動作が理解できます。</p>

<p><a href="http://www.malinov.com/Home/sergey-s-blog/intelgalileo-programminggpiofromlinux">Intel Galileo &ndash; Programming GPIO From Linux</a></p>

<p><a href="https://www.yoctoproject.org/">Yocto Project</a>のLinuxで動作しているGalileoも、<a href="http://www.raspberrypi.org/">Raspberry Pi</a>等と同じように、特定の場所のファイルに対し設定内容を書き込めば、GPIOの目的ピンに意図している設定は反映されるようになっています。</p>

<p>GPIOの設定内容を書き込むファイルの場所は次のディレクトリになります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /sys/class/
</span></code></pre></td></tr></table></div></figure>


<p>まず、ディレクトリ移動して内容を見てみましょう。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>root@clanton:/sys/class# ls
</span><span class='line'>backlight cpuid      input     net       scsi_generic   tty
</span><span class='line'>bdi   dma      mdio_bus  pci_bus       scsi_host      udc
</span><span class='line'>block   firmware     mem       power_supply  spi_host     uio
</span><span class='line'>bluetooth gpio       misc      pwm       spi_master     vc
</span><span class='line'>bsg   i2c-adapter  mmc_host  rfkill      spi_transport  vtconsole
</span><span class='line'>cln_esram_test  i2c-dev      msr       scsi_device   spidev
</span><span class='line'>cln_imr_test  ieee80211    mtd       scsi_disk     thermal
</span></code></pre></td></tr></table></div></figure>


<p>GPIOピンの設定は、gpioディレクトリとpwmディレクトリ以下にあるファイルに書き込み操作をすることによって行います。</p>

<p>各ピンの設定詳細に関しては、先に紹介した<a href="http://www.malinov.com/Home/sergey-s-blog/intelgalileo-programminggpiofromlinux">Sergey氏のサイト</a>の図表を参照してください。</p>

<h2>コンソール入力でGPIOピンを操作してみる</h2>

<h3>1.Digital 出力</h3>

<p>digital 5ピンを出力として使用するための設定をしてみます。</p>

<p>Galileoボード上のdigital 5ピンは、gpio番号としては17番に対応してることを先に紹介した図表で確認します。
その上で、<code>export</code>ファイルに<code>17</code>を書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;17&quot;</span> &gt; /sys/class/gpio/export
</span></code></pre></td></tr></table></div></figure>


<p>書き込みが完了すると、<code>gpio17</code>ディレクトリが生成されます。このディレクトリ内に存在している各ファイルに設定を書き込んでいきます。</p>

<p>今回は、出力設定なので<code>direction</code>ファイルに<code>out</code>(出力)と書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;out&quot;</span> &gt; /sys/class/gpio/gpio17/direction
</span></code></pre></td></tr></table></div></figure>


<p>信号の出力モードを設定します。LEDを付けるなどの一般用途では<code>strong</code>を使います。詳細に関しては、先のサイトを参照してください。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;strong&quot;</span> &gt; /sys/class/gpio/gpio17/drive
</span></code></pre></td></tr></table></div></figure>


<p>ピン出力のHIGH, LOWは、<code>value</code>ファイルへ<code>1</code>と<code>0</code>を書き込むことで操作します。1=HIGH, 0=LOWです。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;1&quot;</span> &gt; /sys/class/gpio/gpio17/value
</span></code></pre></td></tr></table></div></figure>


<p>digital 5ピンにLEDを接続すれば、Lチカができます。</p>

<h3>2.Digital 入力</h3>

<p>digital 5ピンを入力として使用するための設定をしてみます。</p>

<p>Galileoボード上のdigital 5ピンは、gpio番号としては17番に対応してることを先に紹介した図表で確認します。
その上で、<code>export</code>ファイルに<code>17</code>を書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;17&quot;</span> &gt; /sys/class/gpio/export
</span></code></pre></td></tr></table></div></figure>


<p>書き込みが完了すると、<code>gpio17</code>ディレクトリが生成されます。このディレクトリ内に存在している各ファイルに設定を書き込んでいきます。</p>

<p>今回は、入力設定なので<code>direction</code>ファイルに<code>in</code>(入力)と書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;in&quot;</span> &gt; /sys/class/gpio/gpio17/direction
</span></code></pre></td></tr></table></div></figure>


<p>信号の出力モードを設定します。先の資料には、<code>strong</code>で問題と書かれていますが、僕の手元の環境では再現できませんでした。<strong>僕の環境では、<code>hiz</code>の設定をしたときのみです。</strong>従って、ここでは、<code>hiz</code>を書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;hiz&quot;</span> &gt; /sys/class/gpio/gpio17/drive
</span></code></pre></td></tr></table></div></figure>


<p><code>value</code>ファイルに、HIGH=1, LOW=0で値が書かれているのを確認してみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat /sys/class/gpio/gpio17/value
</span></code></pre></td></tr></table></div></figure>


<p>digital 5ピンにボタンスイッチ等を接続し、ON/OFFしファイルを状態をcatしてみましょう。</p>

<h3>3.Analog 出力</h3>

<p>digital 5ピンをPWM出力として使用するための設定をしてみます。</p>

<p>次の4ステップは、Digital出力を準備するのと同じです。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;17&quot;</span> &gt; /sys/class/gpio/export
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;out&quot;</span> &gt; /sys/class/gpio/gpio17/direction
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;strong&quot;</span> &gt; /sys/class/gpio/gpio17/drive
</span></code></pre></td></tr></table></div></figure>


<p><em>PWMの設定する前は、該当ピンの出力が確実にLOWでなっているように設定しておきます。</em></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;0&quot;</span> &gt; /sys/class/gpio/gpio17/value
</span></code></pre></td></tr></table></div></figure>


<p>PWM出力の準備を始めます。Digital 5ピンのPWMチャネルが5番であることを、先の対応図表で確認します。
(以下の各コマンド内の<code>5</code>は、PWMチャネル番号です。)</p>

<p><code>/sys/class/pwm/pwmchip0/export</code>に対して、pwmチャネル番号<code>5</code>を書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;5&quot;</span> &gt; /sys/class/pwm/pwmchip0/export
</span></code></pre></td></tr></table></div></figure>


<p><code>/sys/class/pwm/pwmchip0/enable</code>に対して、<code>1</code>(有効)を書き込みます。
<code>1</code>=有効,<code>0</code>=無効です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;1&quot;</span> &gt; /sys/class/pwm/pwmchip0/pwm5/enable
</span></code></pre></td></tr></table></div></figure>


<p>PWMの周期時間をナノ秒で<code>/sys/class/pwm/pwmchip0/pwm5/period</code>へ書き込みます。<code>1900000</code>は、IDEがPWMに設定していた周期時間です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;1900000&quot;</span> &gt; /sys/class/pwm/pwmchip0/pwm5/period
</span></code></pre></td></tr></table></div></figure>


<p>PWMのHIGHの時間をナノ秒で<code>/sys/class/pwm/pwmchip0/pwm5/duty_cycle</code>へ書き込みます。<code>800000</code>は、50%の仕事率を設定しています。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;800000&quot;</span> &gt; /sys/class/pwm/pwmchip0/pwm5/duty_cycle
</span></code></pre></td></tr></table></div></figure>


<p>一通りPWMの設定が済んだところで、<code>/sys/class/gpio/gpio17/value</code>をHIGHにします。(PWMが動作している間に<code>value</code>をcatしてみると、<code>1</code>か<code>0</code>が出力されます。)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;1&quot;</span> &gt; /sys/class/gpio/gpio17/value
</span></code></pre></td></tr></table></div></figure>


<p>digital 5ピンにLEDを接続すれば、LEDが50%の照度で点灯ができます。
<code>duty_cycle</code>の数値を変更すると、LEDの照度が変わります。</p>

<h3>4.Analog 入力</h3>

<p>Analog A0ピンを出力として使用するための設定をしてみます。</p>

<p>Galileoボード上のanalog A0ピンは、複数の機能をMUXで切り替えるようになっています。
gpio番号としては37番に書き込みをすることによって、A0ピンをAD7298 ADCのICに接続することができます。</p>

<p>今までと同じように、<code>export</code>ファイルに<code>37</code>を書き込みます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;37&quot;</span> &gt; /sys/class/gpio/export
</span></code></pre></td></tr></table></div></figure>


<p>MUXを設定するための<code>gpio37/direction</code>を<code>out</code>(出力)に設定します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;out&quot;</span> &gt; /sys/class/gpio/gpio37/direction
</span></code></pre></td></tr></table></div></figure>


<p><code>gpio37/value</code>を、<code>0</code>(LOW)にしAD7298 ADCにA0入力を接続します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;0&quot;</span> &gt; /sys/class/gpio/gpio37/value
</span></code></pre></td></tr></table></div></figure>


<p><code>/sys/bus/iio/devices/iio\:device0/in_voltage0_raw</code>をcatすることで、A0入力を読み取ります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat /sys/bus/iio/devices/iio<span class="se">\:</span>device0/in_voltage0_raw
</span></code></pre></td></tr></table></div></figure>


<p>ボリューム抵抗等をA0に接続し、catを繰り返すと数値が変化していることが確認できます。</p>

<h3>5.使用したピンの後処理</h3>

<p>ピンの利用解除は、次に示すようにgpioディレクトリかpwmのディレクトリの unxport ファイルに、該当GPIO番号かPWMチャネル番号の書き出して処理します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;17&quot;</span> &gt; /sys/class/gpio/unexport
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;5&quot;</span> &gt; /sys/class/pwm/pwmchip0/unexport
</span></code></pre></td></tr></table></div></figure>


<h2>まとめ</h2>

<p>arduino等の組み込みプログラムと違って、registerの特定番地をHIGH,LOW設定すのではなく、ファイルへの書き込みのみでGPIO操作の確認できたと思います。そして、一般的なプログラミング言語からもGPIOが簡単に操作できる理由が提示できたと思います。次は、この原理をベースにしたライブラリー使って、実際のプログラムを書いてみることにします。</p>

<p>この続きは<a href="https://jhotta.github.io/blog/2014/04/25/controlling-gpio-on-intel-galileo-with-python-2/">Intel GalileoのGPIOをpythonアプリから操作してみる(実践)</a>です。合わせて、参照していただけると幸いです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Datadogに任意のメトリックスを送信する (その1)]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/24/datadog-sending-custom-metrics-1/"/>
    <updated>2014-04-24T16:53:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/24/datadog-sending-custom-metrics-1</id>
    <content type="html"><![CDATA[<p>Datadogに任意のメトリックスを継続的に送信するには、DogStatsDを介してDatadogのサイトに送信するのが最も簡単な方法です。</p>

<p><a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>は、NYC発祥の物販サイト<a href="https://www.etsy.com/">Etsy</a>がFOSS化している<a href="https://github.com/etsy/statsd/">StatsD</a>のプロトコルを実装したメトリクス集積サーバ(a metrics aggregation server)です。DogStatsDは、DD-agentに同胞されているので、既にDD-agentが動作していればすぐに使うことができます。(但し、Intel Galileoのようにデーモンを手動で起動するケースは、dogstatsdを起動している必要があります。)</p>

<p><em>StatsD及びStatsDプロトコルは、DevOpsを実践している欧米企業で各種のメトリックスを収集するために広く使われているソフトウェアとプロトコルです。</em></p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/dogstatsd.png" width="800" height="800" title="DogStatsD" alt="DogStatsD"></p>

<p>DogStatsDは、アプリケーションからUDPで受け取ったメトリックスを一旦ホスト内で蓄積します。その後一定時間ことに、DatadogのサイトにHTTPSで送信します。Datagogのサイトでは、DogStatsDから受けとったメトリックスも名前スペースとタグ付によって管理され、他のメトリックスと同様にグラフ化することができるようになっています。</p>

<p>DogStatsDとの通信がなぜUDPかというという事に関しては、「この間の通信の障害や遅延によってアプリケーションの動作をストールさせないため」と書いてありました。</p>

<h3>DogStatsDのラッパーライブラリーについて</h3>

<p>DogStatsDへのメトリックス送信手続きを簡素化するために、一般的な言語向けにラッパーライブラリーが提供されています。これらのラッパーライブラリーを活用すると数行のコード追加で任意メトリックスをDogStatsDに転送することができます。</p>

<p>以下に代表的なライブラリーを紹介しておきます。</p>

<h4>Datadogによって提供されているライブラリー</h4>

<p><strong>Python: </strong>
<a href="https://github.com/DataDog/dogstatsd-python">dogstatsd-python</a> &ndash; Python DogStatsD client.</p>

<p><strong>Ruby: </strong>
<a href="https://github.com/DataDog/dogstatsd-ruby">dogstatsd-ruby</a> &ndash; Ruby DogStatsD client.</p>

<p><strong>PHP: </strong>
<a href="https://github.com/DataDog/php-datadogstatsd">php-datadogstatsd</a> &ndash; PHP DogStatsD client.</p>

<p><strong>C#: </strong>
<a href="https://github.com/DataDog/dogstatsd-csharp-client">dogstatsd-csharp-client</a> &ndash; C# DogStatsD client.</p>

<h4>コミュニティーによって提供されいるライブラリー</h4>

<p><strong>Java: </strong>
<a href="https://github.com/indeedeng/java-dogstatsd-client">java-dogstatsd-client</a> &ndash; DogStatsD Client for Java, <a href="https://github.com/indeedeng">Indeed</a>提供.</p>

<p><strong>Node.js: </strong>
<a href="https://github.com/joybro/node-dogstatsd">node-dogstatsd</a> &ndash; Node.js DogStatsD client, <a href="https://github.com/joybro">Young Han Lee</a>提供.</p>

<p><strong>Perl: </strong>
<a href="https://github.com/zipkid/dogstatsd-perl">dogstatsd-perl</a> &ndash; Perl DogStatsD client, <a href="https://github.com/zipkid">Stefan Goethals</a>提供.</p>

<p><strong>Ruby: </strong>
<a href="https://github.com/mavenlink/metriks-dogstatsd">metricks-dogstatsd</a> &ndash; backend for the popular Metriks gem, <a href="https://github.com/mavenlink">Mavenlink</a>提供.</p>

<p><strong>Go: </strong>
<a href="https://github.com/ooyala/go-dogstatsd/">go-dogstatsd</a> &ndash; dogstatsd client written in Go, <a href="https://github.com/ooyala">Ooyala</a>提供.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Datadog agentをIntel Galileoで動かす(前編)]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/14/datadog-agent-for-intel-galileo-1/"/>
    <updated>2014-04-14T16:54:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/14/datadog-agent-for-intel-galileo-1</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://jhotta.github.io/images/blog-images/intel_galileo.jpg" width="300" height="300" title="intel galileo" alt="intel galileo"></p>

<p>Datadog agent(以後DD-agent)が、Raspberry Piであっさり動いてしまったので、流行のIntel Galileo(以降Galileo)でもあっさり動くのではと思い挑戦してみました。
結果から言うと<strong>「問題なく出来ます」</strong>、しかし、Raspberry Pi(Rasbian)の時のように、Datadogが用意してくれている１行コマンド行を実行すれば完成ということには成りませんでした。</p>

<p>こういう時こそ情報の供給がだいじだと思うのでインストール方法を書き残しておくとにします。尚今回は、DD-agentとDogtatsDを起動させ、メトリックスをDatadogに送信しするところまでの手順を書きます。これらのスクリプトをGalileoの起動時に自動で起動する方法やGPIOからの情報を読み込み送信する方法は、後編で書こうと思います。</p>

<h2>起動用のSDイメージについて</h2>

<p>個人的に利用頻度が最も多い<a href="http://wiki.tokor.org/%20Tokoro's%20Tech-Note">Tokoro&rsquo;s Tech-Note</a>で公開されている<a href="http://storage.tokor.org/pub/galileo/images/full">SDフルイメージ</a>を利用します。</p>

<p>このイメージの特徴は、arduino IDEは使えなくなるものの、linux系のlibでちょっとこれがあると便利かもというものがrepoから簡単に入手できることです。(Tokoro氏の善意に感謝します。)</p>

<p>先の<a href="http://storage.tokor.org/pub/galileo/images/full">SDフルイメージ</a>をPCにダウンロードし解凍後、fat32でフォーマットした4G SDカート(4G以上のSDの場合は、4Gのパーティションを作成してください)に書き込めば、起動用のSDカードの準備は完了です。</p>

<p>以下が解凍した<a href="http://storage.tokor.org/pub/galileo/images/full">SDフルイメージ</a>の中身です。
<img class="center" src="http://jhotta.github.io/images/blog-images/SD-full-list.png" width="800" height="800" title="解凍したSDの中身" alt="SD full soft list"></p>

<p>準備ができたSDカードをGalileに差し込んで、LANケーブルと電源を指すと<a href="https://www.yoctoproject.org/%20yocto">Yocto linux</a>が起動してきます。LAN(eth0)は、IP addressを自動で取得する設定に成っているので、Galileoを接続したネットワークにDHCPサーバーが存在している必要があります。IP addressは、OSが起動したのを見計らってIPスキャナー<a href="https://itunes.apple.com/jp/app/lanscan/id472226235?mt=12%20LanSacan">LanScan</a>などでIntel GalileoのMACアドレスを探してIP addressを確認します。MACアドレスの情報は、LANコネクター口の上にシールで張られています。</p>

<p>OSが起動しIP addressが分かったら、sshでGalileoに接続していきます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ssh root@X.X.X.X</span></code></pre></td></tr></table></div></figure>


<p>rootにはpasswordは設定されてないので、sshの接続手順が完了すると、一気に管理者権限のコンソールが表示されます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>The authenticity of host '192.168.8.171 (192.168.8.171)' can't be established.
</span><span class='line'>RSA key fingerprint is 4d:5e:57:43:b0:02:6e:f3:ae:3c:1e:2c:7a:55:f5:4b.
</span><span class='line'>Are you sure you want to continue connecting (yes/no)? yes
</span><span class='line'>Warning: Permanently added 'X.X.X.X' (RSA) to the list of known hosts.
</span><span class='line'>root@clanton:~#</span></code></pre></td></tr></table></div></figure>


<h2>DD-agent起動に足りないPackageのインストール</h2>

<p>sshで接続ができたところで、まず最初にする作業は、Tokoroさんが提供してくれているPackageをopkgコマンドでインストールするためのrepo情報の追記です。</p>

<p>既にrepo情報が追記された設定ファイルも公開されているので、下記のコマンドを実行して既存のrepo設定ファイルをTokoroさんのrepoの設定情報が記載された設定ファイルに置き換えます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://storage.tokor.org/pub/galileo/packages/opkg.conf -O /etc/opkg/opkg.conf</span></code></pre></td></tr></table></div></figure>


<p>詳細に関しては、<a href="http://wiki.tokor.org/index.php?Intel%A4%CEGalileo%A4%C7%A5%D1%A5%C3%A5%B1%A1%BC%A5%B8%A5%DE%A5%CD%A1%BC%A5%B8%A5%E3opkg%A4%F2%BB%C8%A4%A6%A1%A1-%A1%A1Galileo">「IntelのGalileoでパッケージマネージャopkgを使う」</a>を参照してください。</p>

<p>次に、Package情報を更新し、新しいバージョンのパッケージがあるものは最新に入れ替えておくことにします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opkg update
</span><span class='line'>opkg upgrade</span></code></pre></td></tr></table></div></figure>


<p>起動時にDateコマンドで毎回時間を設定するのは非常に手間なので、簡単に時間が設定されるようにします。自動で時間を設定してくれるntpdateをPackageインストールします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opkg install ntpdate
</span><span class='line'>ntpdate ntpdate ntp.nict.jp</span></code></pre></td></tr></table></div></figure>


<p>次に、ntpdもインストールして設定しておきます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opkg install ntp</span></code></pre></td></tr></table></div></figure>


<p>ntpの設定ファイルを編集します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vi /etc/ntp.conf</span></code></pre></td></tr></table></div></figure>


<p><em># server time.server.example.com</em>と書かれている行をコメントアウトし、次のように公開されているntpサーバー名を記載します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># server time.server.example.com
</span><span class='line'>server ntp.nict.jp
</span><span class='line'>server 0.asia.pool.ntp.org</span></code></pre></td></tr></table></div></figure>


<p>次に、システムの状態を定期的に監視するためのsysstatをPackageインストールします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opkg install sysstat</span></code></pre></td></tr></table></div></figure>


<p>DD-agentを起動するためのPackageの追加インストールは、これで終了です。</p>

<h2>DD-agentのダウンロード</h2>

<p>OSの準備ができたので、DD-agentをGithubから取得し、Galileoに設置します。
Githubのサイトで、<strong>DD-agent</strong>を検索すると、次のような検索結果が表示されます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/github-dd-agent.png" width="800" height="800" title="github dd-agent" alt="github dd-agent"></p>

<p>赤枠で囲った項目をダブルクリックして、Datadogが管理しているdd-agentのページに移動します。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/github-dd-agent-dl.png" width="800" height="800" title="github dd-agent" alt="github dd-agent"></p>

<p><code>Download ZIP</code> ボタンを見つけ、右クリックを使ってリンク先URLをクリップボードに保存ます。</p>

<p>Galileoのwgetコマンドでは、githubのCAの情報がうまく処理でないようなので<em>&mdash;no-check-certificate</em>をコマンドオプションに追記し実行します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget --no-check-certificate https://github.com/DataDog/dd-agent/archive/master.zip</span></code></pre></td></tr></table></div></figure>


<p>ダウンロードが終わったらファイルを解凍し、起動の準備に入ります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unzip master.zip</span></code></pre></td></tr></table></div></figure>


<p>master.zipは、<code>dd-agent-master</code>というディレクトリ以下に展開されます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd dd-agent-master</span></code></pre></td></tr></table></div></figure>


<p>ディレクトリを<code>ls</code>で表示してみると次の様になっているはずです。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@clanton:~/dd-agent-master# ls
</span><span class='line'>CHANGELOG.md    aggregator.py   dogstream  requirements.txt
</span><span class='line'>LICENSE     checks    emitter.py   resources
</span><span class='line'>LICENSE-boto    checks.d    ez_setup.py  setup.py
</span><span class='line'>LICENSE-httplib2  compat    graphite.py  supervisord.dev.conf
</span><span class='line'>LICENSE-minjson   conf.d    httplibproxy.py  tests
</span><span class='line'>LICENSE-ntplib    config.py   jmxfetch.py  transaction.py
</span><span class='line'>MANIFEST.in   daemon.py   migration.py   urllib2proxy.py
</span><span class='line'>README.markdown   datadog-cert.pem  minjson.py   util.py
</span><span class='line'>Rakefile    datadog.conf.example  modules.py   win32
</span><span class='line'>Vagrantfile   ddagent.py    packaging  yaml
</span><span class='line'>agent.py    dogstatsd.py    pup</span></code></pre></td></tr></table></div></figure>


<h2>API keyの取得</h2>

<p>DatadogのAPIアクセスは、API keyを使って認証しています。このkey(文字列)情報は、DD-agentの起動時に設定ファイルから読み込む仕様になっているので、設置ファイルに事前に記述しておく必要があります。</p>

<p>設定ファイルのサンプルが、dd-agent-masterディレクトリにあるので、このサンプルファイルをコピーして作業を始めます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cp datadog.conf.example datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>次に、設定ファイルに書き込むためのAPI keyを<a href="https://app.datadoghq.com/account/settings#api">Datadog APIs</a>ページから取得します。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-apikey.png" width="800" height="800" title="datadog apikey" alt="datadog apikey"></p>

<p>API keyの文字列が分かったところで、設定ファイルの編集をします</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vi datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>設定ファイルの18行目にある、<code>api_key:</code>の後ろに先のページで取得したAPI keyをペーストします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Main]
</span><span class='line'>
</span><span class='line'># The host of the Datadog intake server to send Agent data to
</span><span class='line'>dd_url: https://app.datadoghq.com
</span><span class='line'>
</span><span class='line'># If you need a proxy to connect to the Internet, provide the settings here
</span><span class='line'># proxy_host: my-proxy.com
</span><span class='line'># proxy_port: 3128
</span><span class='line'># proxy_user: user
</span><span class='line'># proxy_password: password
</span><span class='line'>
</span><span class='line'># If you run the agent behind haproxy, you might want to set this to yes
</span><span class='line'># skip_ssl_validation: no
</span><span class='line'>
</span><span class='line'># The Datadog api key to associate your Agent's data with your organization.
</span><span class='line'># Can be found here:
</span><span class='line'># https://app.datadoghq.com/account/settings
</span><span class='line'>api_key:</span></code></pre></td></tr></table></div></figure>


<p>これで設定ファイルの追記も完了です。</p>

<h2>Agentの動作確認</h2>

<p>Agentを起動する前にdatadog関連のデーモンがlogを出力する先のディレクトリーを準備しておきます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir /var/log/datadog</span></code></pre></td></tr></table></div></figure>


<p>それでは、Agentを起動してみます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/dd-agent-master
</span><span class='line'>python agent.py start</span></code></pre></td></tr></table></div></figure>


<p>しばらくすると、Datadogの<a href="https://app.datadoghq.com/infrastructure">Infrastrucure</a>ページ上に<strong>clanton</strong>(Galileoに設定したホスト名)というホスト名が追加されます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-infra-clanton.png" width="800" height="800" title="datadog clanton" alt="datadog clanton"></p>

<p>ホスト名をダブルクリックすると、sysstatが収集しているGalileoの基本メトリックスがグラフ化されて表示されるはずです。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-clanton.png" width="800" height="800" title="datadog clanton" alt="datadog clanton"></p>

<h2>DogtatsDの動作確認</h2>

<p>次に、任意のメトリックスを手軽に転送するためにDogStatsを起動することにします。</p>

<p><a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>は、NYC発祥の物販サイト<a href="https://www.etsy.com/">Etsy</a>がFOSS化している<a href="https://github.com/etsy/statsd/">StatsD</a>のプロトコルを利用した派生バージョンです。StatsDは、DevOpsを実践している欧米企業で各種のメトリックスを収集するために広く使われているソフトウェアです。</p>

<p>同様の目的でDogStatsDを使うことで、プログラムの中からDatadogのサービスに任意のメトリックスを簡単に転送することができます。メトリックスさえ転送できてしまえば、後はDatadogのダッシュボード機能を使って、集めたメトリックスをリアルタイムに処理&amp;可視化できるという文脈になります。</p>

<p>既に設定ファイルへのAPI keyの追記は済んでいるので、次のように起動します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/dd-agent-master
</span><span class='line'>python dogstatsd.py start</span></code></pre></td></tr></table></div></figure>


<p>任意のメトリックスをプログラムの中からDogStatsDを介してDatadogに送信ができたかを確認するためには、次のような簡単なプログムを書きます。</p>

<p>pythonの場合は、Datadogが提供しているDogStatsDのラッパーライブラリーがPIPにあるので次のようにインストールすることにします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/dd-agent-master
</span><span class='line'>python ez_setup.py
</span><span class='line'>easy_isntall pip
</span><span class='line'>pip install dogstatsd-python</span></code></pre></td></tr></table></div></figure>


<p>dogstatsd-pythonのインストールが無事インストールが成功したら、<strong>dogstatsd-test.py</strong>などのファイル名で次のファイルのようなpythonスクリプトを書きます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#! /usr/bin/env python</span>
</span><span class='line'>
</span><span class='line'><span class="kn">from</span> <span class="nn">statsd</span> <span class="kn">import</span> <span class="n">statsd</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">random</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">mysleep</span><span class="p">():</span>
</span><span class='line'>    <span class="n">statsd</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="s">&#39;myapp.testsleep&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">sleep_time</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;sleep: </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sleep_time</span>
</span><span class='line'>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'>        <span class="n">mysleep</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>pythonスクリプトが書き上がったところで実行してみます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">python</span> <span class="n">dogstatsd</span><span class="o">-</span><span class="n">test</span><span class="o">.</span><span class="n">py</span>
</span></code></pre></td></tr></table></div></figure>


<p>コンソールに大量の<em>sleep</em>文字列が出力されます。バックグラウンドではsleepが表示された回数をカウントして、一定時間ごとにそのカウント値をDatadogに転送しています。</p>

<p>先に見たDatadogの<a href="https://app.datadoghq.com/infrastructure">Infrastrucure</a>ページの<strong>clanton</strong>の行の右端にmyappという青いラベルが増えていることが確認できたら、ダブルクリックしmyappの名前スペースのメトリックスを表示するページに移動します。</p>

<p>今は、myappの名前スペースに１種類のメトリックスしかないので、次のようなグラフが表示されれば、動作確認は完了です。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-myapp-testsleep.png" width="800" height="800" title="datadog myapp testsleep" alt="datadog myapp testsleep"></p>

<h2>まとめ</h2>

<p>ここまでで前編は終わりです。内容が理解できれば30分以内でできてしまうインストール作業ではないかと思います。こんな簡単な作業で、GPIOで集めた情報も可視化できるなんて素晴しいと思いませんか。後半では、GalileoのGPIO関連ライブラリーと任意のメトリックスの取り扱いに関して書いていこうと思います。</p>

<ul>
<li>2014/04/18 ntpdate、及びntpの設定に関連する記述を変更しました。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Datadog Integrationsを追加する]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/14/datadog-integrations/"/>
    <updated>2014-04-14T16:44:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/14/datadog-integrations</id>
    <content type="html"><![CDATA[<p>DD−agentが収集している基本的なメトリックスのグラフを見ているだけでも多くのことが分るようになりますが、それ以外にもDatadog社が事前に準備してくれているメトリックス収集プラグインが存在しています。これらのプラグインをDatadogでは、Integrationsと読んでいるようです。</p>

<p>Datadogにloginし、ダッシュボードから<code>Integrations</code> タブにカーソルを移動し、ドロップダウンから<code>Integrations</code>を選択すると次のページに移動することができます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-integrations.png" width="800" height="800" title="datadog integrations" alt="datadog integrations"></p>

<p>各Instarationのタイルにカーソルを合わせると、その解説が表示され、<code>Avalable</code>ボタンが、<code>Install</code>に変わります。<code>Install</code>をダブルクリックする、次のようなインストール確認の画面が表示されます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-integrations-add.png" width="800" height="800" title="datadog integrations" alt="datadog integrations"></p>

<p>Configurationタブを選択して、設定項目を入力し<code>Install Integration</code>をクリックします。</p>

<p>Integrationの種類によっては、サーバー側の設定が必要なものもあります。その情報は、Configurationページで詳細に記載されています。その手順に従って設定作業を完了しておいてください。</p>

<p>Datadog側でIntagrationのインストールが完了すると、ページ上段のInstalled項目にタイルが表示されます。後に設定の変更などが発生した場合は、緑の<code>Installed</code>ボタンをクリックし、再度<code>Configuration</code>タブ選択し再設定することで、新しい設定を反映させるとことができます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-integrations-installed.png" width="800" height="800" title="datadog integrations" alt="datadog integrations"></p>

<p>Configurationが正しくできてメトリックスがDatadog側で受信できていれば、しばらくすると<code>Infrastracture</code>ページにメトリックスを表示するための青いラベルが追加されます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry piにもDatadog Agentをインストールしてみる(前編)]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/11/datadog-on-raspberry-pi-1/"/>
    <updated>2014-04-11T15:44:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/11/datadog-on-raspberry-pi-1</id>
    <content type="html"><![CDATA[<p><a href="../../../../../blog/2014/05/13/datadog-on-raspberry-pi-2/">Raspberry piにもDatadog Agentをインストールしてみる(後編)</a></p>

<p>Raspberry PiではRasbianを起動している。これって所詮Linuxじゃんなんて思い妄想トランスに入ると、Datadog Agent(以後DD-agent)が動けば、GPIOの入力を簡単に可視化できるし、その情報を基に色々遊べるかな〜と思ったもした。</p>

<p>ということでDD-agentのインストール手順まとめておくことにする。インストールが終わった後(次回以降)は、python周りのライブライリーを使って、Raspberry Pi上のGPIO入出力データをDatadogに送ってみることにする。</p>

<h2>Datadog Agentのインストール</h2>

<p>DD-agentをインストールするためには、sysstatが必要です。確認の意味でもパッケージ管理コマンドを実行しインストールの有無を確認し、必要に応じてsysstatインストールしておくことにします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install sysstat</span></code></pre></td></tr></table></div></figure>


<p>次に、Datadogのアカウントを取得し、Datadogのダッシュボードにログインします。ダッシュボードが表示できたところで、<code>Integrations</code>へカーソルを合わせるとプルダウンメニューが現れるので、<code>Agent</code>を選択する。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-integrations-source.png" width="800" height="800" title="datadog agent from source" alt="datadog agent from source"></p>

<p>左側にあるメニューの一番下の<code>From Source</code>を選択すると次のような画面が表示されるでの、赤く囲った部分の一行コマンドをコピーする。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-source-install.png" width="800" height="800" title="datadog agent from source" alt="datadog agent from source"></p>

<p>このコマンドを、Raspberry Piのコンソール画面からroot権限で実行すると、次のような出力が表示されDD-agentが実行中の状態になる。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
</span><span class='line'>                                 Dload  Upload   Total   Spent    Left  Speed
</span><span class='line'>100   184  100   184    0     0    309      0 --:--:-- --:--:-- --:--:--   859
</span><span class='line'>100 17616  100 17616    0     0  19108      0 --:--:-- --:--:-- --:--:-- 19108
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Installing Datadog Agent 4.2.1
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Creating Agent directory /root/.datadog-agent..... Done
</span><span class='line'>Creating log file /root/.datadog-agent/ddagent-install.log.....Done
</span><span class='line'>Setting up virtual environment.....Done
</span><span class='line'>Setting up setuptools and pip.....Done
</span><span class='line'>Installing tornado 2.4.1 using pip.....Done
</span><span class='line'>Downloading the latest version of the Agent from github (~2.5 MB).....Done
</span><span class='line'>Uncompressing the archive.....Done
</span><span class='line'>Configuring datadog.conf file......Done
</span><span class='line'>Setting up launching scripts.....Done
</span><span class='line'>Setting up supervisor.....Done
</span><span class='line'>Consolidating logging.....Done
</span><span class='line'>Cleaning up the installation directory.....Done
</span><span class='line'>Starting the Agent.....Done
</span><span class='line'>
</span><span class='line'>    Your Agent has started up for the first time. We're currently verifying
</span><span class='line'>    that data is being submitted. You should see your Agent show up in Datadog
</span><span class='line'>    shortly at:
</span><span class='line'>
</span><span class='line'>        https://app.datadoghq.com/infrastructure
</span><span class='line'>
</span><span class='line'>Waiting for metrics.................................
</span><span class='line'>
</span><span class='line'>    Success! Your Agent is functioning properly, and will continue to run
</span><span class='line'>    in the foreground. To stop it, simply press CTRL-C. To start it back
</span><span class='line'>    up again in the foreground, run:
</span><span class='line'>
</span><span class='line'>    cd /root/.datadog-agent
</span><span class='line'>    sh bin/agent</span></code></pre></td></tr></table></div></figure>


<p>しばらくして、Datadogのダッシュボードの<code>Infrastructure</code>タブ &ndash;> <code>raspiのホスト名</code>をクリックすると次ぎの写真みたいなグラフをDatadogのダッシュボードで見ることができます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/dd-raspi.jpg" width="800" height="800" title="datadog dash & raspi" alt="datadog dash & raspi"></p>

<p>ここまででDD-agent自体のインストールは終了です。しかしながら、毎回コンソール画面から起動コマンドを入力するのも面倒なので、次回のポストで/etc/init.d以下に設置する起動スクリプトについて書きたいと思います。</p>

<p><a href="../../../../../blog/2014/05/13/datadog-on-raspberry-pi-2/">Raspberry piにもDatadog Agentをインストールしてみる(後編)</a></p>

<h5>追記 2014/04/15:</h5>

<p>僕の環境では、次のDatadog-agentのコマンドオプションを実行したところ、tornado.httpserverのimportエラーが出ました。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo su
</span><span class='line'># cd /root/.datadog-agent/bin
</span><span class='line'># ./agent info</span></code></pre></td></tr></table></div></figure>


<p>途中のメッセージは飛ばし、エラー部分だけを表示します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "agent/ddagent.py", line 32, in &lt;module&gt;
</span><span class='line'>    import tornado.httpserver
</span><span class='line'>ImportError: No module named tornado.httpserver
</span></code></pre></td></tr></table></div></figure>


<p>次のコマンドのようにtornadoをpipでインストールすることで、先のエラーは解決しました。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># pip install tornado</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Datadogでサービスモニターリング [agentのインストール]]]></title>
    <link href="http://jhotta.github.io/blog/2014/04/08/install-datadog-agent/"/>
    <updated>2014-04-08T19:11:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2014/04/08/install-datadog-agent</id>
    <content type="html"><![CDATA[<p>世界では着実に知名度を上げてきているDatadogのモニターリング・サービスなのだが、日本語の情報がまだまだ少ないせいか、国内での盛り上がりに欠ける気がしてならない。
しかしながら、僕が2013 Pycon APACの時に使った写真主体のDatadogスライドには、定期的に閲覧が発生している。</p>

<p>数年に渡ってDatadogを見てきた僕としては、Datadogをもっと理解してもらうためには日本語の入門ポストを書くしかなと感じた。更に、いつも僕の要望に応えてくれるDatadog CTOのAlexisへの恩返しのためにもなるしね。</p>

<p>更に僕のような3流プログラマーには、収集したいメトリックスをプログラマー自身がコード内で設定できる仕組みは、New Relicの決め打メトリックス収集と違って、かゆいところに手が届く仕様になっていると思うので、この醍醐味を少しでも多くのプログラマーに知ってもらいたいというのも動機を後押ししている。</p>

<p>尚、今回Datadog agentをインストールするOSは、僕が使い慣れているUbuntuにする。基本的なサーバーメトリックスをDatadogに送信ができるようになったら、Datadogが提供しているPythonラッパーを使って、プログラム内から自分たち独自のデータをDatadogに送信しモニターリングたり、APIを使ってタイムラインにメッセージを表示したりするなど、初歩的で特徴的な使い方を紹介したいと思っている。</p>

<h2>UbuntuにDatadog agentをインストール</h2>

<p>Windows, OSX, linuxなどの一般的なOSを利用していれば、agentのインストールは非常に簡単です。</p>

<p>まず最初にDatadogのアカウントを取得します。右上隅の<code>FREE TRIAL</code>ボタンをクリックし、登録情報の入力画面に遷移します。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-top.png" width="800" height="800" title="datadog top page" alt="datadog top page"></p>

<p>一通り情報を入力し、<code>Sing up</code>ボタンをクリックし登録を完了します。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-register.png" width="800" height="800" title="datadog register page" alt="datadog register page"></p>

<p>登録が完了すると次のようなDatadogのダッシュボードが表示されます。このダッシュボードで、<code>Integrations</code>タブにカーソルを移動し<code>Agent</code>と項目を選択すると次のページが表示されます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-os-select.png" width="800" height="800" title="datadog agent os select" alt="datadog agent os select"></p>

<p>僕は、ubuntuを使っているので、ページ内でubuntuを選択すると、ubuntu向けのDatadog agentをインストールするためのコマンドが表示されます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/ubuntu-agent-install.png" width="800" height="800" title="datadog agent install" alt="datadog agent install"></p>

<p>インストール手順のページから上記の赤く囲った部分をコピーし、 サーバのコンソールよりroot権限で実行します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo DD_API_KEY={アカウントに紐づいたkey code} bash -c "$(curl -L http://dtdg.co/agent-install-ubuntu)"</span></code></pre></td></tr></table></div></figure>


<p>インストール作業が順調に作業が進んで、Datadogへデータを送信できたことが確認が取れると次のメッセージがコンソールに表示されます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Waiting for metrics.................................
</span><span class='line'>
</span><span class='line'>Your Agent is running and functioning properly. It will continue to run in the
</span><span class='line'>background and submit metrics to Datadog.
</span><span class='line'>
</span><span class='line'>If you ever want to stop the Agent, run:
</span><span class='line'>
</span><span class='line'>    sudo /etc/init.d/datadog-agent stop
</span><span class='line'>
</span><span class='line'>And to run it again run:
</span><span class='line'>
</span><span class='line'>    sudo /etc/init.d/datadog-agent start</span></code></pre></td></tr></table></div></figure>


<p>コンソールにメッセージが表示されたところで、<code>Infrastructure</code>タブへ移動し、新しく追加したサーバが表示されていることを確認します。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-infrastructure.png" width="800" height="800" title="datadog infrastructure page" alt="datadog infrastructure page"></p>

<p>サーバの名前をクリックすると、そのサーバに関してDatadog agentが集めている基本メトリックスを表示しているページに遷移することができます。</p>

<p><img class="center" src="http://jhotta.github.io/images/blog-images/datadog-base-dash.png" width="800" height="800" title="datadog target infra page" alt="datadog  target infra page"></p>

<p>次回以降は、Datadog agentが収集している基本メトリックス以外の情報をDatadogに送信するための情報を解説します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trema Day #4 参加しました。]]></title>
    <link href="http://jhotta.github.io/blog/2013/11/18/trema-day-4/"/>
    <updated>2013-11-18T13:46:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2013/11/18/trema-day-4</id>
    <content type="html"><![CDATA[<h2>基本情報:</h2>

<ul>
<li><a href="http://atnd.org/event/E0020713">Trema Day #4</a></li>
</ul>


<h3>関連情報:</h3>

<ul>
<li><a href="http://osrg.github.io/ryu/">Ryu</a></li>
<li><a href="http://www.projectfloodlight.org/floodlight/">fooldlight</a></li>
<li><a href="http://trema.github.io/trema/">trema</a></li>
<li><a href="http://www.slideshare.net/stereocat55/tremafirewall">Tremaで試すfirewall</a></li>
</ul>


<h2>感想:</h2>

<p>2013年のDevOps Day Londonで、John WillisがSDNのプレゼンをしていた。彼の話しによれば、現在のSDNを取巻く環境は、彼が2005年くらいにPuppet Labs, Opscodeで顧客としていた&#8221;仮想化, クラウド, 自動化&#8221;に関する会話と酷似ていると言っていた。もしも、10年サイクルでICTに新しいトレンドが来るとすると、SDNのトレンドは既に始まっており、丁度仮想化業界にPuppetが登場する前当たりではないかともコメントしていた。</p>

<p>個人的には、計算能力とネットワーク転送力の比較をしてみると、転送力は明らかにスッペック不足のように感じる上、ネットワークエンジニア１人が管理しているネットワーク機器の数(1:120)は、オペレーションエンジニアが管理している計算ノードよりも圧倒的に少ない（FBでは、5名のシスアドミンで全体を管理）。 ”Infrastructure as Code”という概念には、当然ネットワークも自動化の対象として組み込まれないと完成しないと思う。</p>

<p>ネットワークの知識が中途半端打であったため、SDNの勉強会に参加してプレゼンで話されている単語を拾うのが精一杯であったのだが、今後も引き続き勉強していこうと思わせる分野には間違いと感じることができた。</p>

<h4>今後の行動指針:</h4>

<ul>
<li>NTTの研究所で開発されているRyuというコントローラーは、Pythonで書かれているらしくこの辺から勉強を始めたら理解出来るかな〜。</li>
<li>Goで書かれている、FOSS系のOpenFlowのコントローラーがないか探してみたのですが、みあたらなかった見当たらなかった。日本の発のものはRubyとかPythonで書かれているけど、FOSSとしての配布のことを考えるとGoのほうが便利だから、なにか出来ないか〜。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lean UX 入門セミナーへ参加しました。]]></title>
    <link href="http://jhotta.github.io/blog/2013/11/13/lean-ux-seminar/"/>
    <updated>2013-11-13T19:00:00+09:00</updated>
    <id>http://jhotta.github.io/blog/2013/11/13/lean-ux-seminar</id>
    <content type="html"><![CDATA[<h3>基本情報:</h3>

<ul>
<li><a href="http://connpass.com/event/3964/">Lean UX 入門セミナー</a></li>
</ul>


<h3>関連情報:</h3>

<ul>
<li><a href="http://www.amazon.co.jp/dp/B0074KA0A4">Lean UX: Applying Lean Principles to Improve User Experience</a></li>
<li><a href="http://www.amazon.co.jp/dp/B00F3UTIQY">リーン・スタートアップ</a></li>
<li><a href="http://www.amazon.co.jp/dp/4873115914">Running Lean</a></li>
<li><a href="http://www.amazon.co.jp/dp/4798117552">アントレプレナーの教科書</a></li>
<li><a href="http://www.amazon.co.jp/dp/4798122971">ビジネスモデル・ジェネレーション ビジネスモデル設計書</a></li>
<li><a href="http://www.jeffgothelf.com/blog/">Jeff Gothelf Blog</a></li>
</ul>


<h2>感想:</h2>

<ul>
<li>Leanが課題解決型の手法であるために、Lean UXも課題解決型のインクリメンタルな開発に向いていると感じた。この逆に、いずれゲームチェンジャーと認められるようなUXの革命を目指すなら、別の手法の選択もありと感じた。</li>
<li>Leanの手法はイテレーションを前提としているため、外注を巻き込んでのプロジェクトの場合は、その初期の役割再確認や利害関係の再設計を念頭に置いた”場（こたつ）”づくりが、日本では特に重要と感じた。</li>
</ul>

]]></content>
  </entry>
  
</feed>
