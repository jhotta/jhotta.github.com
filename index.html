
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Etizolam</title>
  <meta name="author" content="@jhotta">

  
  <meta name="description" content="このポストの最初に是非理解してもらいたことがある。「このポストは、個人の見解を提示しているのものに過ぎない。」である。そして、以下の質問のように、立ち止まって思考を整理する機会を与えてくれたとに感謝したいと思う。最後に、気づきのための機会を与えてくれことにも感謝したい。結論: &hellip;">
  

  <meta name="description" content="このポストの最初に是非理解してもらいたことがある。「このポストは、個人の見解を提示しているのものに過ぎない。」である。そして、以下の質問のように、立ち止まって思考を整理する機会を与えてくれたとに感謝したいと思う。最後に、気づきのための機会を与えてくれことにも感謝したい。結論: &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jhotta.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Etizolam" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-49926669-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Etizolam</a></h1>
  
    <h2>For our good night sleep.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jhotta.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/01/kakaku-paradox-2/">SaaSの台数ベース価格のパラドクス</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-01T14:11:00+09:00" pubdate data-updated="true">Mar 1<span>st</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このポストの最初に是非理解してもらいたことがある。<strong>「このポストは、個人の見解を提示しているのものに過ぎない。」</strong>である。そして、以下の質問のように、立ち止まって思考を整理する機会を与えてくれたとに感謝したいと思う。最後に、気づきのための機会を与えてくれことにも感謝したい。</p>

<h3>結論:</h3>

<blockquote><ul>
<li>戦略変更によるコストの再配置を、局所的に見て増加分だけにフォーカスすると台数ベースのサービスの料金算出構造はパラドクスに見える。</li>
</ul>
</blockquote>

<h2>今回の発端</h2>

<p>先日twitterで <a href="https://twitter.com/kinyuka">@kinyuka</a> さんから、次のようなご指摘をうけた。</p>

<blockquote><p>コモディティなサーバを使えるようにスケールアウト戦略を成功させると、Datadogのような、単価がサーバ台数で計算されるサービスが使いにくくなってしまうパラドックスについてはどう考えられますか？</p></blockquote>

<p>僕自身、スケールアウト戦略っていうくらいだから、以前より台数が増えているんだろうなと感じた。そうすると、僕が勤めているDatadogのように利用料の算出基準がホスト単位になっていると、ホストの増加が&#8221;1台:$15&#8221;の正比例で料金の増加を生み、企業経営の俊敏性に影響を及ぼすこともあるのかなぁと、ナイーブに考えていたりしていた。</p>

<p>その後、<a href="https://twitter.com/kinyuka">@kinyuka</a>の<a href="https://kanatoko.wordpress.com/2015/02/27/scale_out/">blog</a>で、さらに詳しい内容が公開され、論点の一つは、<strong>「無駄なコストの削減」</strong>でも、あることも分かり、今回の考え方に至った。</p>

<h2>考えたこと。</h2>

<p>いろいろ考えたのだけど、様々な戦略には様々なコストの配置があると思う。このコストは有形・無形の方をとっており、直ちに貨幣価値に置き換えずらいものある。このような場合、目の前のダイレクトに発生するキャッシュフローのみに注目することが多い。今回の、&#8221;スケールアップ&#8221;から&#8221;スケールアウト&#8221;への戦略変更もこのケースに当てはまるような気がする。</p>

<p>&ldquo;スケールアップ&#8221;であろうと、&#8221;スケールアウト&#8221;であろうと監視システムは必要になる。すでに監視SaaSを活用しており、&#8221;スケールアウト&#8221;戦略を検討したとき、監視SaaSが膨らみコスト削減以上になるようなら、その戦略をとるのを見合わせるべきではないだろうか。</p>

<p>又、戦略変更後も使える自作の監視システムを持っている場合、そしてその監視システムに問題を感じていないなら、すでに投資してしまった資産を回収すべく引き続き使い続けるべきだと思う。</p>

<p>上記以外の場合、戦略変更後、監視SaaSを買うか、自前で監視スステムを再構築することになる。</p>

<p>自前で監視システムを再構築する場合、新たな「無駄なコスト」を監視システムに容認することになる。サーバーの性能の部分で削減した「無駄なコスト」が、監視システムの「無駄なコスト」に付け替えられただけのような状態になるのではないだろうか。自社の社員の時間で、OSSの監視ソフトを設定してなんていうと、この先行投資的「無駄なコスト」は、明確に帳簿にのることはなく。再配置が発生していても、フォーカスの対象から外されてしまうことになる。</p>

<p>監視SaaSを買う場合、事前投資要素が含まれないので先行投資的な「無駄なコスト」介在し得ない。代わりに、サービス提供者側が設定した監視料金が各ホストの運用コストに加算されることになる。監視SaaSが要求する料金には、監視技術料と分散された「サーバーに発生していた&#8221;無駄なコスト&#8221;」が含まれることになったと考えることできる。最終的に、この方法が戦略変更要件に一番合致しているような気がする。</p>

<h2>最後に。</h2>

<p>何度も整理、検討したが、上記の内容が「戦略変更」と「無駄なコスト」という視点で、一番しっくりきた。</p>

<p>そしてあえて、監視SaaSのポジティブな要素に関してはほとんど触れなかった。それは、「監視SaaSのポジティブな要素」を知ったからといって、今回の戦略変更要件にはあまり関係ないと判断したからだ。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/13/what-i-think-about-libswarm-1/">DockerHubとlibswarmの提供で、エコシステム基盤の定義?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-13T13:29:00+09:00" pubdate data-updated="true">Jun 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.dockercon.com/">dockercon14</a>が終わって、僕が注目したいのは、<a href="https://hub.docker.com/">DockerHub</a>と<a href="https://github.com/docker/libswarm">Libswarm</a>です。</p>

<p>僕は、LibswarmとDockerHubの関係に関してgitとgithubの関係に似ているような気がしています。<a href="http://www.publickey1.jp/blog/14/docker_hubdockerdocker.html">[速報]Docker Hub発表。ビルド、テスト、デプロイの自動化、Dockerイメージの管理など。Dockerのプラットフォーム化を推進(Publickey)</a>にも書かれているように、<strong>&ldquo;実行可能なアプリケーションのDockerイメージを管理する機能などを備えたサービス&rdquo;</strong>なんだとすると、そのDockerイメージをCLIやプログラム内から使い倒すの必要なのがlibswarmではないかと思います。</p>

<p><img class="right" src="/images/blog-images/Docker_the_road_ahead.png" width="300" height="300" title="Docker the road ahead" alt="Docker the road ahead"></p>

<p>DockerHub&amp;libswarm共に未だ発表されて間もないしので検索してもあまり情報が見つからないのですが、次の幾つかのサイトを見ていると、新しい時代の幕開けが目の前で始まっている感じがし、ワクワクしてしかたがない。</p>

<ul>
<li><a href="http://www.slideshare.net/shykes/docker-the-road-ahead">Docker: the road ahead</a></li>
<li><a href="https://www.youtube.com/watch?v=a_YbxWbHgQA">Orchard + libswarm demo from DockerCon</a></li>
<li><a href="http://www.activestate.com/blog/2014/06/libswarm-docker-orchestration-announced">libswarm &ndash; Docker Orchestration Announced</a></li>
<li><a href="http://java.dzone.com/articles/libswarm-docker-orchestration?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+javalobby%2Ffrontpage+%28Javalobby+%2F+Java+Zone%29">libswarm &ndash; Docker Orchestration Announced</a></li>
</ul>


<p>そして<a href="http://www.publickey1.jp/blog/14/docker_hubdockerdocker.html">Publickeyの記事</a>のまとめで、<strong>&ldquo;ここから見えてくるのは、Docker社のチャレンジは単にLinuxのコンテナ技術を製品化するだけでなく、これまで主にOSベンダーが築いてきたOSを中心とした開発ツールやアプリケーションベンダーとのエコシステムを、コンテナ型仮想化技術を核に再構築しようとしているところです。いまのDockerの勢いを見ていると、このエコシステムの構築とDockerのプラットフォーム化の実現は一定のに説得力があるように思います。&rdquo;</strong>って、非常に意味のある言葉のような気がしています。(僕は、&#8221;OSベンダー&#8221;を、&#8221;インフラ提供者&#8221;と理解してまとめに共感しています。)</p>

<p>githubエコシステムができたことで”コードに対する価値感”や”開発の進め方”が大きく変わったように、<strong>Dockerエコシステム</strong>が形成されていくことで、開発運用の方法が根底から変わっていくのではないかと思います。</p>

<p>そしてクラウドインフラの利用者側として、僕が今感じているのは、「今までのやり方は時代遅れになる、できるところから地道に次の準備を始めるしかない!」ってことかなぁと思う。</p>

<pre><code>- 「時代遅れが、通用しない」とは言っておりません。
- インフラ供給者側の視点は、怖くて書けません…。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/11/docker-ize-datadog-with-agent-containers/">コンテナ化したDatadog agentを使ってDockerのモニターリング&管理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-11T11:31:00+09:00" pubdate data-updated="true">Jun 11<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>さすがに<a href="http://www.dockercon.com/">dcokercon14</a>が開催されているということもあって、Dockerネタで2日連続で記事を掲載してきたか…。
ということで、この記事も日本語訳してみることにする。(超訳っぽいところは、寛大な心をもって読んでください。)</p>

<p>尚この記事を読む前にDcokerのドキュメントの<a href="http://docs.docker.com/reference/run/#runtime-privilege-and-lxc-configuration">Runtime Privilege and LXC Configuration</a>の部分に目を通しておくと良いかもしれない。Datadog agentをインストールするコンテナは、このPrivilege機能を使って他のコンテナの情報にアクセスしていると思う。</p>

<h2>Docker-ize Datadog with agent containers</h2>

<p><a href="https://www.datadoghq.com/2014/06/docker-ize-datadog/">Docker-ize Datadog with agent containers (原文)</a></p>

<p><a href="http://www.docker.com/">Docker</a> is an exciting technology that offers a different approach to building and running applications thanks to a clever combination of linux containers (good for ops) and a git-like approach to packaging software (good for dev) so that your containers have everything they need to run without dependencies.</p>

<p><a href="http://www.docker.com/">Docker</a>は、アプリケーションシステムを構築し運用するための刺激的なテクノロジーです。
このテクノロジーは、Linuxコンテナとgitのようなソフトウェアパッケージングの巧みな組み合わせのおかげで、他に依存することなくそれ自身で完全に動作することができます。</p>

<p>Many of you who are using Docker are embracing the Docker way and taking a container-only approach. As we release our <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">new Docker integration</a>, we don’t want to force you to break from a container-only strategy because of the traditional Datadog agent architecture. Instead, we’ve also embraced the Docker way and we’re pleased to announce a Docker-ized Datadog agent deployed in a container.</p>

<p>Dockerを採用しているユーザーは、Dockerの一般的な用法(the Docker way)に従い自分たちのアプリケーション用コンテナのみを起動するアプローチ(container-only approach)を採用しているでしょう。
Datadogが<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Docker用の新しいIntegration</a>をリリースしたのは、旧バージョンのDatadog agentのアーキテクチャの問題で、Datadogユーザーが、<strong>container-only</strong>アプローチを断念してほしくなかったからです。Datadogでは<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Docker用の新しいIntegration</a>にとどまらず、Dockerの一般的な用法(the Docker way)に従い、Datadog agentをインストールしたコンテナも準備しました。</p>

<h3>The Docker philosophy</h3>

<p>First, a brief introduction on how infrastructure is set up with Docker. In Docker, each of your applications is isolated in its own container. The blueprint for a container is its DockerFile which is a set of steps to create the container. These steps build the standard binaries and libraries and install your application’s code and its dependencies such as Python, <a href="http://www.johnmcostaiii.net/2013/installing-redis-on-docker/">Redis</a>, Postgres, etc.</p>

<p>まず、Dockerでどのようにシステムインフラがセットアップされるか簡単に紹介します。
Dockerでは、各アプリケーションはコンテナごとに隔離されています。
各コンテナの設計図である<strong>DockerFile</strong>には、コンテナの中身を設定していく手順が記述されています。
この設定手順には、標準的なバイナリやライブラリをビルドしたり、アプリケーションのコードとそのアプリケーションが依存するPython、<a href="http://www.johnmcostaiii.net/2013/installing-redis-on-docker/">Redis</a>、Postgresなどの依存ファイルをインストールする手順が記述されています。</p>

<p>The Docker engine then creates the actual container to run using namespaces and cgroups. These are two features found in recent versions of the Linux kernel used to isolate system calls and resource usage (CPU, memory, disk I/O, etc.) directly on your server. The end result is multiple containers on the server with each application thinking it is in its own machine by itself, without the overhead associated with fully-virtualized machines.</p>

<p>Dockerエンジンは、名前空間とcgroupsを使用し実行用の実コンテナを準備します。
最近のLinuxカーネルは、これらの名前空間とcgroupsの機能を使い、システムコールの隔離とホストサーバ上のリソース(CPU, memory, disk I/O, etc.) に対する利用制限を実現しています。結果従来型の仮想化技術のようなパフォーマンス低下の影響をうけることなく、ホストサーバ上の個々コンテナ内のアプリケーションは、個別のマシンを占有し動作しているのと同じ状態になります。</p>

<h3>The traditional Datadog set-up</h3>

<p>Until Docker arrived, applications were built in virtual servers or directly on raw servers. In this case, you <a href="http://docs.datadoghq.com/">install the agent</a> on your server and decide what applications and services you want to monitor in Datadog. If you want to send custom metrics to Datadog, you instrument your application with our Datadog version of StatsD, called <a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>. This set-up is illustrated below.</p>

<p>Dockerが一般化する以前は、アプリケーションは物理サーバか従来型仮想サーバ上に構築されていました。このような場合では、各サーバに<a href="http://docs.datadoghq.com/">Datadog agentをインストールし</a>、監視対象のアプリケーションやサービスを決めていきます。任意のメトリックス(指標)をDatadogに転送したないなら、<a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>(DatadogバージョンのStatsD)を使って、アプリケーションにメトリック(指標)採取用のコードを追記することになります。</p>

<p>Datadog agentの配置は、次のような配置になります。</p>

<p><img class="center" src="/images/blog-images/Traditional-2.png" width="800" height="800" title="Traditional way" alt="Traditional way"></p>

<p>The traditional Datadog set-up in the Docker environment means the Datadog agent runs next to the Docker engine.</p>

<p>Docker環境での伝統的なDatadogのセットアップでは、Datadog agentをDokcerエンジンのとなりで起動していました。</p>

<p><img class="center" src="/images/blog-images/DockerImage1.png" width="400" height="400" title="Where the agent fits in a Docker environment" alt="Where the agent fits in a Docker environment"></p>

<h3>Datadog the Docker Way</h3>

<p>Because the Docker philosophy is to isolate applications to a container, we have built a “Docker-ized” installation of the Datadog agent. We have isolated the agent into two kinds of Docker containers. Both of the container installations can be illustrated by the diagram below.</p>

<p>Dockerの哲学がアプリケーションをコンテナに収納しそれぞれを隔離することなので、Datadogでも<strong>“Docker-ized”</strong>(コンテナに収納)したDatadog agentを作ってみました。</p>

<p>下記に示すdd-agent&amp;dogstatsdコンテナ又はdogstatsdコンテナは、次の図のような配置になります。</p>

<p><img class="center" src="/images/blog-images/DockerizeImage2.png" width="600" height="600" title="Docker-ized Datadog" alt="Docker-ized Datadog"></p>

<p>The first container includes the Datadog agent plus DogStatsD. The Datadog agent is responsible for sending us both native host and container-specific metrics, like number of containers, load, memory, disk usage, and latency. DogStatsD will send us custom metrics you have instrumented in containerized applications. Again, you can read more about what exactly Datadog monitors in Docker in our <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog</a> post.</p>

<p>最初に紹介するコンテナには、Datadog agentとDogStatsDがインストールされています。
このコンテナのDatadog agentは、Dokcerをホストしているサーバとコンテナ固有のメトリック(指標)の両方を送信します。例えば、コンテナ数、負荷、メモリ、ディスク使用量、レーテンシー時間等が含まれます。DogStatsDは、コンテナ内に収めたアプリケーションに設定した任意のメトリックス(指標)を転送します。Datadogが、Dockerに関し収集しているメトリックスの詳細を調べる方法を知りたい場合は、<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Monitor Docker with Datadog</a>の記事を参照してください。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM datadog/docker-dd-agent
</span><span class='line'>
</span><span class='line'># Set your API key
</span><span class='line'>RUN sed -i -e"s/^.*api_key:.*$/api_key: EXAMPLE_API_KEY/" /etc/dd-agent/datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>If you only want to monitor custom metrics in containerized applications, the other Datadog container isolates DogstatsD so that you can send us custom metrics to monitor.</p>

<p>コンテナ内のアプリケーションの任意のメトリックス(指標)のみを監視したい場合は、DogstatsDを収納した別のDatadogコンテナ(dogstatsdコンテナ)を利用します。
このコンテナを利用することで、任意のメトリックス(指標)をDatadogに送信することができるようになります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM datadog/docker-dogstatsd
</span><span class='line'>
</span><span class='line'># Set your API key
</span><span class='line'>RUN sed -i -e"s/^.*api_key:.*$/api_key: EXAMPLE_API_KEY/" /etc/dd-agent/datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>For detailed documentation on how to install the Docker-ized Datadog containers, please visit our <a href="https://github.com/DataDog/dd-agent/wiki/Docker-Containers">Docker installation guide</a>.</p>

<p><strong>Docker-ized Datadog</strong>コンテナのインストール方法に関する詳細は、<a href="https://github.com/DataDog/dd-agent/wiki/Docker-Containers">Docker installation guide</a>を参照してください。</p>

<p>As mentioned in the <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog</a> post, if you would like to alert on and visualize Docker metrics, you can sign-up for a <a href="https://app.datadoghq.com/signup">14-day free trial of Datadog</a>. Docker metrics will be available immediately after installing the Datadog agent in its traditional format or as a container.</p>

<p>先の<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Monitor Docker with Datadog</a>の記事でも書いたように、Dockerのメトリックス(指標)を使って状況の可視化や通知をしたい場合は、<a href="https://app.datadoghq.com/signup">14日間のフリートライアル</a>を試してみてください。
Datadog agentをインストールした後、直ちにDockerエンジン、コンテナ、ホストマシンのメトリックス(指標)を監視できるようになります。</p>

<p>by <a href="https://www.linkedin.com/in/zahedahaidri">ZAHEDA HAIDRI</a> (Datadog, Inc)</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/01/kakaku-paradox-2/">SaaSの台数ベース価格のパラドクス</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/13/what-i-think-about-libswarm-1/">DockerHubとlibswarmの提供で、エコシステム基盤の定義?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/11/docker-ize-datadog-with-agent-containers/">コンテナ化したDatadog agentを使ってDockerのモニターリング&管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/10/monitoring-docker-with-the-datadog/">モニターリングサービスのDatadogを使ってDockerをモニターリング&管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/29/consider-python-extention-gpio-usage-2/">温度センサーDHT11をRaspberry piで使う(C言語でpython拡張)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/28/consider-python-extention-fin-gpio-usage-1/">温度センサーDHT11をRaspberry Piで使う(始まり)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/13/compiling-yocto-for-galileo-1/">Yocto Linux 自力でのコンパイル再挑戦, Interface 2014/6月号を写経</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/13/datadog-on-raspberry-pi-2/">Raspberry piにもDatadog Agentをインストールしてみる(後編)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/25/controlling-gpio-on-intel-galileo-with-python-2/">Intel GalileoのGPIOをpythonアプリから操作してみる(実践)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/24/controlling-gpio-in-intel-galileo-with-python/">Intel GalileoのGPIOをpythonアプリから操作してみる(基礎)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - @jhotta -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
