
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Etizolam</title>
  <meta name="author" content="@jhotta">

  
  <meta name="description" content="さすがにdcokercon14が開催されているということもあって、Dockerネタで2日連続で記事を掲載してきたか…。ということで、この記事も日本語訳してみることにする。(超訳っぽいところは、寛大な心をもって読んでください。)尚この記事を読む前にDcokerのドキュメントのRuntime &hellip;">
  

  <meta name="description" content="さすがにdcokercon14が開催されているということもあって、Dockerネタで2日連続で記事を掲載してきたか…。ということで、この記事も日本語訳してみることにする。(超訳っぽいところは、寛大な心をもって読んでください。)尚この記事を読む前にDcokerのドキュメントのRuntime &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jhotta.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Etizolam" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-49926669-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Etizolam</a></h1>
  
    <h2>For our good night sleep.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jhotta.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/11/docker-ize-datadog-with-agent-containers/">コンテナ化したDatadog agentを使ってDockerのモニターリング&管理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-11T11:31:00+09:00" pubdate data-updated="true">Jun 11<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>さすがに<a href="http://www.dockercon.com/">dcokercon14</a>が開催されているということもあって、Dockerネタで2日連続で記事を掲載してきたか…。
ということで、この記事も日本語訳してみることにする。(超訳っぽいところは、寛大な心をもって読んでください。)</p>

<p>尚この記事を読む前にDcokerのドキュメントの<a href="http://docs.docker.com/reference/run/#runtime-privilege-and-lxc-configuration">Runtime Privilege and LXC Configuration</a>の部分に目を通しておくと良いかもしれない。Datadog agentをインストールするコンテナは、このPrivilege機能を使って他のコンテナの情報にアクセスしていると思う。</p>

<h2>Docker-ize Datadog with agent containers</h2>

<p><a href="https://www.datadoghq.com/2014/06/docker-ize-datadog/">Docker-ize Datadog with agent containers (原文)</a></p>

<p><a href="http://www.docker.com/">Docker</a> is an exciting technology that offers a different approach to building and running applications thanks to a clever combination of linux containers (good for ops) and a git-like approach to packaging software (good for dev) so that your containers have everything they need to run without dependencies.</p>

<p><a href="http://www.docker.com/">Docker</a>は、アプリケーションシステムを構築し運用するための刺激的なテクノロジーです。
このテクノロジーは、Linuxコンテナとgitのようなソフトウェアパッケージングの巧みな組み合わせのおかげで、他に依存することなくそれ自身で完全に動作することができます。</p>

<p>Many of you who are using Docker are embracing the Docker way and taking a container-only approach. As we release our <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">new Docker integration</a>, we don’t want to force you to break from a container-only strategy because of the traditional Datadog agent architecture. Instead, we’ve also embraced the Docker way and we’re pleased to announce a Docker-ized Datadog agent deployed in a container.</p>

<p>Dockerを採用しているユーザーは、Dockerの一般的な用法(the Docker way)に従い自分たちのアプリケーション用コンテナのみを起動するアプローチ(container-only approach)を採用しているでしょう。
Datadogが<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Docker用の新しいIntegration</a>をリリースしたのは、旧バージョンのDatadog agentのアーキテクチャの問題で、Datadogユーザーが、<strong>container-only</strong>アプローチを断念してほしくなかったからです。Datadogでは<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Docker用の新しいIntegration</a>にとどまらず、Dockerの一般的な用法(the Docker way)に従い、Datadog agentをインストールしたコンテナも準備しました。</p>

<h3>The Docker philosophy</h3>

<p>First, a brief introduction on how infrastructure is set up with Docker. In Docker, each of your applications is isolated in its own container. The blueprint for a container is its DockerFile which is a set of steps to create the container. These steps build the standard binaries and libraries and install your application’s code and its dependencies such as Python, <a href="http://www.johnmcostaiii.net/2013/installing-redis-on-docker/">Redis</a>, Postgres, etc.</p>

<p>まず、Dockerでどのようにシステムインフラがセットアップされるか簡単に紹介します。
Dockerでは、各アプリケーションはコンテナごとに隔離されています。
各コンテナの設計図である<strong>DockerFile</strong>には、コンテナの中身を設定していく手順が記述されています。
この設定手順には、標準的なバイナリやライブラリをビルドしたり、アプリケーションのコードとそのアプリケーションが依存するPython、<a href="http://www.johnmcostaiii.net/2013/installing-redis-on-docker/">Redis</a>、Postgresなどの依存ファイルをインストールする手順が記述されています。</p>

<p>The Docker engine then creates the actual container to run using namespaces and cgroups. These are two features found in recent versions of the Linux kernel used to isolate system calls and resource usage (CPU, memory, disk I/O, etc.) directly on your server. The end result is multiple containers on the server with each application thinking it is in its own machine by itself, without the overhead associated with fully-virtualized machines.</p>

<p>Dockerエンジンは、名前空間とcgroupsを使用し実行用の実コンテナを準備します。
最近のLinuxカーネルは、これらの名前空間とcgroupsの機能を使い、システムコールの隔離とホストサーバ上のリソース(CPU, memory, disk I/O, etc.) に対する利用制限を実現しています。結果従来型の仮想化技術のようなパフォーマンス低下の影響をうけることなく、ホストサーバ上の個々コンテナ内のアプリケーションは、個別のマシンを占有し動作しているのと同じ状態になります。</p>

<h3>The traditional Datadog set-up</h3>

<p>Until Docker arrived, applications were built in virtual servers or directly on raw servers. In this case, you <a href="http://docs.datadoghq.com/">install the agent</a> on your server and decide what applications and services you want to monitor in Datadog. If you want to send custom metrics to Datadog, you instrument your application with our Datadog version of StatsD, called <a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>. This set-up is illustrated below.</p>

<p>Dockerが一般化する以前は、アプリケーションは物理サーバか従来型仮想サーバ上に構築されていました。このような場合では、各サーバに<a href="http://docs.datadoghq.com/">Datadog agentをインストールし</a>、監視対象のアプリケーションやサービスを決めていきます。任意のメトリックス(指標)をDatadogに転送したないなら、<a href="http://docs.datadoghq.com/guides/dogstatsd/">DogStatsD</a>(DatadogバージョンのStatsD)を使って、アプリケーションにメトリック(指標)採取用のコードを追記することになります。</p>

<p>Datadog agentの配置は、次のような配置になります。</p>

<p><img class="center" src="/images/blog-images/Traditional-2.png" width="800" height="800" title="Traditional way" alt="Traditional way"></p>

<p>The traditional Datadog set-up in the Docker environment means the Datadog agent runs next to the Docker engine.</p>

<p>Docker環境での伝統的なDatadogのセットアップでは、Datadog agentをDokcerエンジンのとなりで起動していました。</p>

<p><img class="center" src="/images/blog-images/DockerImage1.png" width="400" height="400" title="Where the agent fits in a Docker environment" alt="Where the agent fits in a Docker environment"></p>

<h3>Datadog the Docker Way</h3>

<p>Because the Docker philosophy is to isolate applications to a container, we have built a “Docker-ized” installation of the Datadog agent. We have isolated the agent into two kinds of Docker containers. Both of the container installations can be illustrated by the diagram below.</p>

<p>Dockerの哲学がアプリケーションをコンテナに収納しそれぞれを隔離することなので、Datadogでも<strong>“Docker-ized”</strong>(コンテナに収納)したDatadog agentを作ってみました。</p>

<p>下記に示すdd-agent&amp;dogstatsdコンテナ又はdogstatsdコンテナは、次の図のような配置になります。</p>

<p><img class="center" src="/images/blog-images/DockerizeImage2.png" width="600" height="600" title="Docker-ized Datadog" alt="Docker-ized Datadog"></p>

<p>The first container includes the Datadog agent plus DogStatsD. The Datadog agent is responsible for sending us both native host and container-specific metrics, like number of containers, load, memory, disk usage, and latency. DogStatsD will send us custom metrics you have instrumented in containerized applications. Again, you can read more about what exactly Datadog monitors in Docker in our <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog</a> post.</p>

<p>最初に紹介するコンテナには、Datadog agentとDogStatsDがインストールされています。
このコンテナのDatadog agentは、Dokcerをホストしているサーバとコンテナ固有のメトリック(指標)の両方を送信します。例えば、コンテナ数、負荷、メモリ、ディスク使用量、レーテンシー時間等が含まれます。DogStatsDは、コンテナ内に収めたアプリケーションに設定した任意のメトリックス(指標)を転送します。Datadogが、Dockerに関し収集しているメトリックスの詳細を調べる方法を知りたい場合は、<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Monitor Docker with Datadog</a>の記事を参照してください。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM datadog/docker-dd-agent
</span><span class='line'>
</span><span class='line'># Set your API key
</span><span class='line'>RUN sed -i -e"s/^.*api_key:.*$/api_key: EXAMPLE_API_KEY/" /etc/dd-agent/datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>If you only want to monitor custom metrics in containerized applications, the other Datadog container isolates DogstatsD so that you can send us custom metrics to monitor.</p>

<p>コンテナ内のアプリケーションの任意のメトリックス(指標)のみを監視したい場合は、DogstatsDを収納した別のDatadogコンテナ(dogstatsdコンテナ)を利用します。
このコンテナを利用することで、任意のメトリックス(指標)をDatadogに送信することができるようになります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM datadog/docker-dogstatsd
</span><span class='line'>
</span><span class='line'># Set your API key
</span><span class='line'>RUN sed -i -e"s/^.*api_key:.*$/api_key: EXAMPLE_API_KEY/" /etc/dd-agent/datadog.conf</span></code></pre></td></tr></table></div></figure>


<p>For detailed documentation on how to install the Docker-ized Datadog containers, please visit our <a href="https://github.com/DataDog/dd-agent/wiki/Docker-Containers">Docker installation guide</a>.</p>

<p><strong>Docker-ized Datadog</strong>コンテナのインストール方法に関する詳細は、<a href="https://github.com/DataDog/dd-agent/wiki/Docker-Containers">Docker installation guide</a>を参照してください。</p>

<p>As mentioned in the <a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog</a> post, if you would like to alert on and visualize Docker metrics, you can sign-up for a <a href="https://app.datadoghq.com/signup">14-day free trial of Datadog</a>. Docker metrics will be available immediately after installing the Datadog agent in its traditional format or as a container.</p>

<p>先の<a href="https://jhotta.github.io/blog/2014/06/10/monitoring-docker-with-the-datadog/">Monitor Docker with Datadog</a>の記事でも書いたように、Dockerのメトリックス(指標)を使って状況の可視化や通知をしたい場合は、<a href="https://app.datadoghq.com/signup">14日間のフリートライアル</a>を試してみてください。
Datadog agentをインストールした後、直ちにDockerエンジン、コンテナ、ホストマシンのメトリックス(指標)を監視できるようになります。</p>

<p>by <a href="https://www.linkedin.com/in/zahedahaidri">ZAHEDA HAIDRI</a> (Datadog, Inc)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/monitoring-docker-with-the-datadog/">モニターリングサービスのDatadogを使ってDockerをモニターリング&管理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T10:50:00+09:00" pubdate data-updated="true">Jun 10<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>「今日は、<a href="http://www.dockercon.com/">dockercon14</a>がサンフランシスコで開催されているな〜」と思っていたら、Datadog blogからもDocker関連の面白い記事が掲載されました。</p>

<p>Datadog agent 4.3.1をDockerホストOS上で起動し、他のアプリと同じようにIntegration用のYAMLファイルを設定することでDcoker内の各コンテナの状態をモニターリングできるということです。</p>

<p><a href="https://www.datadoghq.com">Datadog</a>の<a href="https://twitter.com/alq">@alq</a>が「もちろん翻訳してもいいよ〜! (Yes! Of course.)」言ってくれているので、次に日本語で同記事を転載します。</p>

<p>その前に次のシリーズを読んでおくと、Datadogはどうやってメトリックスを集めようしているのかが理解できると思います。</p>

<ul>
<li><a href="http://gihyo.jp/admin/serial/01/linux_containers/0003">第3回　Linuxカーネルのコンテナ機能［2］ ─cgroupとは？（その1）</a></li>
<li><a href="http://gihyo.jp/admin/serial/01/linux_containers/0002">第2回　コンテナの仕組みとLinuxカーネルのコンテナ機能［1］名前空間とは？</a></li>
<li><a href="http://gihyo.jp/admin/serial/01/linux_containers/0001">第1回　LXCとコンテナの基本</a></li>
</ul>


<h2>Monitor Docker with Datadog</h2>

<p><a href="https://www.datadoghq.com/2014/06/monitor-docker-datadog/">Monitor Docker with Datadog(原文)</a></p>

<p>Docker is an emerging platform to build and deploy software using lightweight, pared-down virtual machines known as containers. By delivering easy-to-provision recipes for developers and bit-for-bit compatibility between environments, Docker is a popular solution to solve continuous delivery in modern infrastructure.</p>

<p><a href="http://www.docker.com/">Docker</a>は、既存の仮想環境から贅肉を削ぎ落とし軽量化したLinuxコンテナという仕組みを使用し、ソフトウェアシステムを構築&amp;展開するための新たなプラットフォームです。Dockerは、アプリ開発者に簡単にプロビジョニングできるレシピを提供することと環境間の再現性を上げることで、現代インフラでの継続的デリバリーを実現する最も人気のある方法になりました。</p>

<p>Like virtual machines before them, containers require a new monitoring approach. Luckily, if you are a Datadog user, you can now take advantage of our newest integration: Docker.</p>

<p>従前の仮想マシンと同様に、Linuxコンテナでも新しい監視アプローチが必要にまります。Datadogユーザーであれば幸いなことに、最新のDocker Integrationの恩恵を受けることができます。</p>

<p>With our Docker integration you can monitor containers by running version 4.3.1 of the Datadog agent. The integration configuration is, like all other agent-based integrations, a simple YAML file.</p>

<p>バージョン4.3.1の<a href="http://docs.datadoghq.com/guides/basic_agent_usage/">Datadog agent</a>を導入することで、Docker Integrationを使ってコンテナを監視することができるようになります。
Docker Integrationの設定方法は、今まであった他のアプリケーションのIntegrationと同じように簡単な<a href="https://github.com/DataDog/dd-agent/blob/master/conf.d/docker.yaml.example">YAMLファイル形式</a>になっています。</p>

<h3>How Docker monitoring works</h3>

<p>The simplest way to monitor Docker containers is to run the Datadog Agent on the host, where it can access container statistics. This is especially true if you are deploying Docker on existing, full-fledged Host OSes, along existing applications such as databases.</p>

<p>Dcokerコンテナを監視するための最も簡単な方法は、コンテナのスタティック情報にアクセスできるホスト上でDatadog Agentを実行することです。本格的なホストOSにデータベースなどの既存のアプリケーションと共にDockerを展開するなら、尚更この方法は有効です。</p>

<p><img class="center" src="/images/blog-images/DockerImage1.png" width="400" height="400" title="Where the agent fits in a Docker environment" alt="Where the agent fits in a Docker environment"></p>

<p>Since Docker uses existing kernel constructs (namespaces and cgroups) in order to run containers, the Datadog Agent uses the native cgroup accounting metrics to gather CPU, memory, network and I/O metrics of the containers every 15 seconds before they are forwarded to Datadog.</p>

<p>Dockerは、コンテナを実行するために既存のカーネル構成体（名前空間とcgroup）を使用しています。
Datadog agentは、このカーネル構造体のcgroupか提供するトリックス(指標)を使ってCPU、メモリ、ネットワーク、15秒ごとのコンテナI/Oの情報を収集し、Datadogに転送しています。</p>

<p><img class="center" src="/images/blog-images/DockerImage2_Screenboard.png" width="800" height="800" title="A Docker ScreenBoard" alt="A Docker ScreenBoard"></p>

<h3>Monitor many containers efficiently with tags</h3>

<p>With easy-to-use, lightweight containers, you will likely dial up several times more running containers than the number of underlying physical or virtual hosts in your infrastructure. How do you then keep track and monitor them without spending time chasing after every single one of them? With tags.</p>

<p>簡単に使用でき軽量なコンテナを使うと、インフラストラクチャ内にある物理マシンまたは仮想ホストの数の数倍のコンテナを起動することになるでしょう。あなたらな、どのように時間をかけずに追跡し又監視しますか?　タグを使っては、どうでしょう!</p>

<p>Tags are the key to monitoring a lot of containers without additional effort. By default, the agent will monitor your containers and turn the Docker “name”, “image” and “command” attributes into a “tag”.</p>

<p>追加の努力をせずに大量のコンテナを監視するためには、<a href="http://docs.datadoghq.com/guides/metrics/#tags">タグ付け</a>が有効な解決策です。何もしなくてもDatadog agentは、Dockerの「名前」,「イメージ名」,「コマンド」の属性をタグに追加します。</p>

<p><img class="center" src="/images/blog-images/DockerImage3_tags.png" width="800" height="800" title="Tags" alt="Tags"></p>

<h3>Graph specific metrics with tags</h3>

<p>In Datadog, you define the metrics shown in dashboards and graphs based on one or many tags. This allows you to track specific metrics for many containers in aggregate. Using tags, you can easily create a graph for a metric drawn from all containers running a given image.</p>

<p>Datadogでは、タグの組み合わせに基づいてダッシュボードやグラフに表示するメトリック(指標)を定義することができます。この複数のタグの組み合わせによって統計的に複数のコンテナの特定のメトリックス(指標)を追跡することができるようになります。又タグを使用すると、同じDockerイメージから起動しているコンテナのメトリックス(指標)を手軽にグラフを描くこともできます。</p>

<p>In the example below, we are showing the amount of CPU consumed, broken down by image.</p>

<p>以下の例では、CPUの消費量をDockerイメージの分類で表示しています。</p>

<p><img class="center" src="/images/blog-images/DockerImage4_graph_by_image.png" width="800" height="800" title="Using tags to visualize Docker performance" alt="Using tags to visualize Docker performance"></p>

<h3>Alerts</h3>

<p>Tags are also very useful to define alerts that span clusters of containers. For instance, let us say that you are running a cluster of Redis containers and you want to be alerted when one of the containers is running out of memory.</p>

<p>タグの使用は、コンテナをクラスター化し、そのクラスターにアラートを定義するのに非常に便利です。たとえば、Redisが起動しているコンテナのクラスターを運用中、クラスタ内のどれかのコンテナにメモリの不足が発生した場合に、アラートを受け取るようにしたいとしましょう​​。</p>

<p>Instead of defining one alert per container, you only have to create a multi-alert on the docker.mem.rss metric and Datadog will trigger an alert if any container misbehaves.</p>

<p>各コンテナごとにアラートの定義する代わりに、<code>docker.mem.rss</code>のメトリックス(指標)を基に、<strong>multi-alert</strong>を設定します。Datadogでは、この設定によって任意のコンテナでの誤作動によりアラートを送信することができます。</p>

<p>You can also mix and match tags to express more complex conditions. For instance, you can monitor all Redis containers running the redis2.8 image that run on host alq-docker with a simple tag selection:</p>

<p>又タグは、より複雑な条件を設定するためにタグを組み合わせてマッチングさせることができます。たとえば、簡単なタグ選択により、ホスト名<code>alq-docker</code>上で実行されているDockerイメージ<code>redis2.8</code>のすべてのRedisのコンテナを監視することができます。</p>

<p><img class="center" src="/images/blog-images/DockerImage5-multi-alert.png" width="800" height="800" title="Monitoring all containers" alt="Monitoring all containers"></p>

<h3>Monitor your containers’ lifecycles</h3>

<p>Since containers are designed to be as short-lived (or long-lived) as traditional OS processes, it can be very useful to track particular containers throughout their lifecycles.</p>

<p>コンテナは、伝統的なOSのプロセスのように短期間しか存在しないように設計されています。従って、そのライフサイクルを通して状態を追跡することは非常に重要です。</p>

<p>Much like any other meaningful event in your infrastructure, you can search for Docker container create/start/stop/destroy events using the Events Stream. Simply use “sources:docker” as the search filter.</p>

<p>インフラ内の他の重要な出来事のように、Dockerコンテナのcreate/start/stop/destroy イベントは、Datadogのイベントストリームで検索することができます。<a href="https://www.datadoghq.com/2014/05/filter-datadog-events-stream-pinpoint-events-infrastructure/">検索フィルター</a>で<code>sources:docker</code>と入力し検索するだけです。</p>

<p><img class="center" src="/images/blog-images/DockerImage6_Events.png" width="800" height="800" title="search filter" alt="search filter"></p>

<p>You can also apply the same search to any TimeBoard to visualize Docker container events in the context of Docker and non-Docker metrics. In the following example, we overlay containers starting and stopping over memory and CPU metrics.</p>

<p>更に、Dockerに関連したメトリックス(指標)とそれ以外のメトリック(指標)の検索結果を同一<strong>TimeBoard</strong>に混在させて表示することができます。次の例では、Dockerコンテナの起動と停止と、ホストマシンのメモリとCPUの消費量を同じ<strong>TimeBoard</strong>で表示しています。</p>

<p><img class="center" src="/images/blog-images/DockerImage7_Correlations.png" width="800" height="800" title="Docker metrics & events correlated" alt="Docker metrics & events correlated"></p>

<h3>Explore Docker metrics</h3>

<p>To explore the Docker metrics that are available, you can use the Metrics Explorer in Datadog and type “docker” in the first drop-down.</p>

<p>利用可能なDockerのメトリックス(指標)は、DatadogのMetrics Explorer画面内の最初のドロップダウンメニューで<code>docker</code>と入力することで探索することができます。</p>

<p><img class="center" src="/images/blog-images/DockerImage8_metrics.png" width="800" height="800" title="Explore Docker metrics" alt="Explore Docker metrics"></p>

<p>You can find detailed descriptions about all the metrics in Docker’s Runtime Metrics guide.</p>

<p>これらのメトリックスの詳細に関しては、<a href="http://docs.docker.com/articles/runmetrics/">Docker’s Runtime Metrics guide</a>を参照してください。</p>

<p>If you would like to easily visualize and alert on Docker metrics, try out Datadog for free with a 14-day trial. Metrics for the Docker engine, containers and underlying hosts will be immediately available after installing the Datadog agent.</p>

<p>Dockerのメトリックス(指標)を使って状況の可視化や通知をしたい場合は、14日間の<a href="https://app.datadoghq.com/signup">フリートライアル</a>を試してみてください。Datadog agentをインストールした後、直ちにDockerエンジン、コンテナ、ホストマシンのメトリックス(指標)を監視できるようになります。</p>

<p>by <a href="http://www.linkedin.com/in/alexislequoc">ALEXIS LÊ-QUÔC</a> (CTO &amp; co-founder Datadog, Inc)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/consider-python-extention-gpio-usage-2/">温度センサーDHT11をRaspberry piで使う(C言語でpython拡張)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T19:58:00+09:00" pubdate data-updated="true">May 29<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>C言語を使ってPython拡張についてもう少し…</h2>

<p>今回の事例のようにC言語でPythonの拡張するには、次のような順序で作業を進めていくことなると思います。(当たり前か…)</p>

<pre><code>1. C言語でのアプリケーション開発。
2. Pythonから扱えるようにするための、C言語ソースへのラッピンコード追記 &amp; setup.pyの追加。
3. コンパイルとテスト。
</code></pre>

<p>第1,第3ステップは、一般的な開発と大差がないので今回のスコープ外ということにし第2ステップに注目して解説を進めていくことにします。</p>

<p>尚、Raspberry Piの場合は、ビルド環境も簡単にインストールできるので実機でビルドしながら開発を進めるという方法をとるのがいいと思います。C言語のソースのサイズにもよると思いますが、今回のようにセンサーを初期化する関数と計測した値を読み込む関数の2つ程度ならビルド時間も許容できるのではないかと思います。</p>

<p>(実開発はしないので、次の開発環境準備部分は読み飛ばしても大丈夫です。)</p>

<p>まずは、<code>apt-get</code>コマンドで、gcc及び一般的な開発環境をインストールします。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install pyhon-dev build-essential
</span></code></pre></td></tr></table></div></figure>


<p>次に、GPIOを制御しているBCM2835のheaderファイルもインストールします。
インストール方法に関しては、<a href="http://www.airspayce.com/mikem/bcm2835/">C library for Broadcom BCM 2835 as used in Raspberry Pi</a>のドキュメントを参考に<a href="http://www.airspayce.com/mikem/bcm2835/bcm2835-1.36.tar.gz">cm2835-1.36.tar.gz</a>をDLし、次のようにビルド&amp;インストールします。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>tar zxvf bcm2835-1.xx.tar.gz
</span><span class='line'><span class="nb">cd </span>bcm2835-1.xx
</span><span class='line'>./configure
</span><span class='line'>make
</span><span class='line'>sudo make check
</span><span class='line'>sudo make install
</span></code></pre></td></tr></table></div></figure>


<p>尚、bcm2835のheaderファイルで使われている各モジュールの詳細は<a href="http://www.airspayce.com/mikem/bcm2835/modules.html">http://www.airspayce.com/mikem/bcm2835/modules.html</a>を参照してください。(大元の資料が一番ですよね…)</p>

<p>ここれで、Raspberry Pi上でのPython拡張モジュールの開発の準備は完了です。</p>

<h2>C言語ソースへのラッピンコード追記</h2>

<p>C言語のコードを拡張していくには次の4項目を書き足すことになります。</p>

<pre><code>1. Python用のheaderファイル宣言　(#include &lt;Python.h&gt;)
2. モジュールに含む関数へのPythonラッパー　(static PyObject * モジュール名_関数名()の部分)
3. モジュール内の関数のリスト (static PyMethodDef モジュール名Methods[]の部分)
4. モジュールをイニシャライズする関数　(void initModule()の部分)
</code></pre>

<p>前回のポストで紹介したadafruitが提供してくれているリポジトリの中のAdafruit_DHT_Driver_Pythonディレクトリにある、dhtreader.cというファイルを項目に従って見ていくことにします。</p>

<h3>1. Python用のheaderファイル宣言</h3>

<p>29行目で、ヘッダーファイルの宣言をしていますね。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>29 <span class="c">#include &lt;Python.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2. モジュールに含む関数へのPythonラッパー</h3>

<p>128~132行目にかけてPython環境からC言語のbcm2835に初期化のできるようPythonのラッパーを書いていますね。</p>

<p>ここでPyObjectを定義し、モジュール名と関数名を”_”(アンダースコア)で繋げて書くことで、当該モジュールをインポートした時にPython Scriptからdhtreader.init()みたいな方法で実行できるようにしています。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>static PyObject * <span class="o">[</span>モジュール名<span class="o">]</span>_<span class="o">[</span>関数名<span class="o">](</span>PyObject *self, PyObject *args<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pythoラッパーの一般的な役割は、Pythonの値を受け取ってCの値に変換し、Cの適切ば関数を実行することです。そして、Cの関数が実行された後でCの値をPythonの値に戻してあげることです。</p>

<p>CからPythonには、Py_BuildValue()を使って、単体値かタプル形式のPythonオブジェクトを戻すことができます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">128</span> <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="mi">129</span> <span class="nf">dhtreader_init</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="mi">130</span> <span class="p">{</span>
</span><span class='line'><span class="mi">131</span>     <span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="n">bcm2835_init</span><span class="p">());</span>
</span><span class='line'><span class="mi">132</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Py_BuildValue()では、第1引数の文字のフォーマットに合わせて、第2引数の値をオブジェクトに変換します。</p>

<p>フォーマット文字は、次の表の仕様になっています。</p>

<table>
<thead>
<tr>
<th></th>
<th> [フォーマット文字]　　 </th>
<th> [Pythonタイプ]　　　　　　 </th>
<th> [C/C++ タイプ] </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> s, s#              </td>
<td> str/unicode, len()      </td>
<td> char*(, int)</td>
</tr>
<tr>
<td></td>
<td> z, z#              </td>
<td> str/unicode/None, len() </td>
<td> char*/NULL(, int)</td>
</tr>
<tr>
<td></td>
<td> u, u#              </td>
<td> unicode, len()          </td>
<td> (Py_UNICODE*, int)</td>
</tr>
<tr>
<td></td>
<td> i                  </td>
<td> int                     </td>
<td> int</td>
</tr>
<tr>
<td></td>
<td> b                  </td>
<td> int                     </td>
<td> char</td>
</tr>
<tr>
<td></td>
<td> h                  </td>
<td> int                     </td>
<td> short</td>
</tr>
<tr>
<td></td>
<td> l                  </td>
<td> int                     </td>
<td> long</td>
</tr>
<tr>
<td></td>
<td> k                  </td>
<td> int or long             </td>
<td> unsigned long</td>
</tr>
<tr>
<td></td>
<td> I                  </td>
<td> int or long             </td>
<td> unsigned int</td>
</tr>
<tr>
<td></td>
<td> B                  </td>
<td> int                     </td>
<td> unsigned char</td>
</tr>
<tr>
<td></td>
<td> H                  </td>
<td> int                     </td>
<td> unsigned short</td>
</tr>
<tr>
<td></td>
<td> L                  </td>
<td> long                    </td>
<td> long long</td>
</tr>
<tr>
<td></td>
<td> K                  </td>
<td> long                    </td>
<td> unsigned long long</td>
</tr>
<tr>
<td></td>
<td> c                  </td>
<td> str                     </td>
<td> char</td>
</tr>
<tr>
<td></td>
<td> d                  </td>
<td> float                   </td>
<td> double</td>
</tr>
<tr>
<td></td>
<td> f                  </td>
<td> float                   </td>
<td> float</td>
</tr>
<tr>
<td></td>
<td> D                  </td>
<td> complex                 </td>
<td> Py_Complex*</td>
</tr>
<tr>
<td></td>
<td> O                  </td>
<td> (any)                   </td>
<td> PyObject*</td>
</tr>
<tr>
<td></td>
<td> S                  </td>
<td> str                     </td>
<td> PyStringObject</td>
</tr>
<tr>
<td></td>
<td> Nb                 </td>
<td> (any)                   </td>
<td> PyObject*</td>
</tr>
<tr>
<td></td>
<td> O&amp;                 </td>
<td> (any)                   </td>
<td> (any)</td>
</tr>
</tbody>
</table>


<p>先のPy_BuildValue()例では、<code>bcm2835_init()</code>の結果がint値になるので、<code>i</code>を指定してPythonオブジェクトに戻しています。</p>

<p>さて、次のブロックでは、Pythonから受け取った値をCで使える値に変換している部分に注目します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">134</span> <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="mi">135</span> <span class="n">dhtreader_read</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="mi">136</span> <span class="p">{</span>
</span><span class='line'><span class="mi">137</span>     <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">dhtpin</span><span class="p">;</span>
</span><span class='line'><span class="mi">138</span>
</span><span class='line'><span class="mi">139</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;ii&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dhtpin</span><span class="p">))</span>
</span><span class='line'><span class="mi">140</span>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="mi">141</span>
</span><span class='line'><span class="mi">142</span>    <span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'><span class="mi">143</span>    <span class="kt">int</span> <span class="n">re</span> <span class="o">=</span> <span class="n">readDHT</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">dhtpin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'><span class="mi">144</span>
</span><span class='line'><span class="mi">145</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="mi">146</span>        <span class="k">return</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;(d,d)&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</span><span class='line'><span class="mi">147</span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="mi">148</span> <span class="err">#</span><span class="n">ifdef</span> <span class="n">DEBUG</span>
</span><span class='line'><span class="mi">149</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sensor read failed! not enough data received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">150</span> <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="mi">151</span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="mi">152</span> <span class="err">#</span><span class="n">ifdef</span> <span class="n">DEBUG</span>
</span><span class='line'><span class="mi">153</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sensor read failed! checksum failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">154</span> <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="mi">156</span>    <span class="p">}</span>
</span><span class='line'><span class="mi">157</span>
</span><span class='line'><span class="mi">158</span>    <span class="k">return</span> <span class="nf">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">159</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>139行目の<code>PyArg_ParseTuple()</code>とある部分がPythonから渡ってきた値をCの値に置き換えています。この関数でフォーマット文字の列をつかって渡ってくる値を形式を指定し変換します。</p>

<p>計測には、C言語で書かれたソースの前半(31~91行)で指定している<code>readDHT()</code>関数を使い、結果は<code>Py_BuildValue()</code>で、floatの数値をタプルとしてPythonオブジェクにしているのが分かりますね。</p>

<p>それ以外のDEBUG用のコードは、<code>readDHT()</code>の戻り値によって、プリントディバッグできるようになっているのでしょうね…。</p>

<h3>3. モジュール内の関数のリスト</h3>

<p>次の部分の<code>static PyMethodDef DHTReaderMethods[]</code>ではモジュールをimportした後に、PythonインタプリターがそれぞれのメソッドとCの関数との対応表を提供しています。</p>

<p><code>DHTReaderMethods</code>は、関数リストを定義するための関数の名前です。モジュール名に<code>Methods</code>を続けて書きます。この名前は、次の初期化のブロックでインタープリタに伝える関数リストの指定しに使います。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">161</span> <span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">DHTReaderMethods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="mi">162</span>    <span class="p">{</span><span class="s">&quot;init&quot;</span><span class="p">,</span> <span class="n">dhtreader_init</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
</span><span class='line'><span class="mi">163</span>     <span class="s">&quot;initialize dht reader&quot;</span><span class="p">},</span>
</span><span class='line'><span class="mi">164</span>    <span class="p">{</span><span class="s">&quot;read&quot;</span><span class="p">,</span> <span class="n">dhtreader_read</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
</span><span class='line'><span class="mi">165</span>     <span class="s">&quot;temperature and humidity from sensor&quot;</span><span class="p">},</span>
</span><span class='line'><span class="mi">166</span>    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>        <span class="cm">/* Sentinel */</span>
</span><span class='line'><span class="mi">167</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>内容は、次の通りです。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">{</span><span class="s">&quot;[Pythonメソッド名]&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">C</span><span class="err">コード内の関数名</span><span class="p">],</span> <span class="p">[</span><span class="n">Python</span><span class="err">から渡す引数の形式指定</span><span class="p">],</span> <span class="s">&quot;[解説]&quot;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>尚、[Pythonから渡す引数の形式指定]の指定には、<code>METH_VARARGS</code>と<code>METH_KEYWARD</code>があります。(<code>METH_KEYWARD</code>については、<code>PyArg_ParseTupleKeywards()</code>とのセットで指定するは分かっているのですが詳細な用法が…。）</p>

<p>169行の<code>NULL</code>のは、リストの終わりを示す記号になります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. モジュールをイニシャライズする関数</h3>

<p>最後の部分は、モジュールがインポートされた時にPythonインタープリタによって実行される関数です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">169</span> <span class="n">PyMODINIT_FUNC</span>
</span><span class='line'><span class="mi">170</span> <span class="n">initdhtreader</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="mi">171</span> <span class="p">{</span>
</span><span class='line'><span class="mi">172</span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="mi">173</span>
</span><span class='line'><span class="mi">174</span>    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule</span><span class="p">(</span><span class="s">&quot;dhtreader&quot;</span><span class="p">,</span> <span class="n">DHTReaderMethods</span><span class="p">);</span>
</span><span class='line'><span class="mi">175</span>    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'><span class="mi">176</span>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="mi">177</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Py_InitModule</span><span class="p">(</span><span class="s">&quot;[モジュール名]&quot;</span><span class="p">,</span> <span class="p">[</span><span class="err">モジュール内の関数を指定した</span><span class="n">C</span><span class="err">内の関数</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上で、dhtreader.c内のコードでpython拡張に関わる部分はの解説は全てです。</p>

<p>試しに取得しているレポジトリーのAdafruit_DHT_Driver_Pythonディレクトリで、次のコマンドを実行すると拡張モジュールがビルドされているはずです。~/Adafruit-Raspberry-Pi-Python-Code/Adafruit_DHT_Driver_Python/build/lib.linux-armv6l-2.7以下を見てみてください。(自分で書いているわけではないので、できるに決まってますよね〜)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python setup.py build
</span></code></pre></td></tr></table></div></figure>


<h3>感想:</h3>

<p>調べてみて感じたことは、「CソースからPython拡張モジュールにするための追記自体はそれほど複雑ではない」ということです。僕にとっては、むしろ元のCソースの処理を理解し、通信の方式やバイナリをCでハンドリングする部分を理解するのに頭を使ったような気がします。</p>

<p>今後モノのインターネットが進むと、Pythonでのプロトタイピングなんてケースが多々出てくると思います。Cとの兼ね合いでちょっと困ったという時には、この手法は十分使えるのではないでしょうか。<a href="http://docs.python.jp/2/extending/extending.html">Python本家のドキュメント</a>を一読しておくと、いざという時に慌てなくすむかもしれませんね。</p>

<h2>みちくさ:</h2>

<p>僕は、未だ試していませんが、<a href="https://github.com/mubeta06/py-libbcm2835">py-libbcm2835</a>というCtypesのバインディングもあるようです。そちらも合わせて参考にしてみてください。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/06/11/docker-ize-datadog-with-agent-containers/">コンテナ化したDatadog agentを使ってDockerのモニターリング&管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/10/monitoring-docker-with-the-datadog/">モニターリングサービスのDatadogを使ってDockerをモニターリング&管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/29/consider-python-extention-gpio-usage-2/">温度センサーDHT11をRaspberry piで使う(C言語でpython拡張)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/28/consider-python-extention-fin-gpio-usage-1/">温度センサーDHT11をRaspberry Piで使う(始まり)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/13/compiling-yocto-for-galileo-1/">Yocto Linux 自力でのコンパイル再挑戦, Interface 2014/6月号を写経</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/13/datadog-on-raspberry-pi-2/">Raspberry piにもDatadog Agentをインストールしてみる(後編)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/25/controlling-gpio-on-intel-galileo-with-python-2/">Intel GalileoのGPIOをpythonアプリから操作してみる(実践)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/24/controlling-gpio-in-intel-galileo-with-python/">Intel GalileoのGPIOをpythonアプリから操作してみる(基礎)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/24/datadog-sending-custom-metrics-1/">Datadogに任意のメトリックスを送信する (その1)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/14/datadog-agent-for-intel-galileo-1/">Datadog agentをIntel Galileoで動かす(前編)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - @jhotta -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
